buildscript {
    repositories {
        jcenter()
        mavenCentral()
    }
    dependencies {
        classpath 'cz.habarta.typescript-generator:typescript-generator-gradle-plugin:2.23.603'
    }
}

plugins {
    id "com.github.psxpaul.execfork" version "0.1.13"
}

apply plugin: 'cz.habarta.typescript-generator'

def webappDir = "$projectDir/webapp"


dependencies {
    implementation(
        project(":common"),
        project(":jersey"),
        project(":bhive"),
        project(":interfaces"),
        'org.whitesource:pecoff4j:0.0.2.1'
    )
    testCompile project(path: ":jersey", configuration: 'testRuntime')
}

sourceSets {
    main {
        resources {
            srcDirs = ["$webappDir/dist"]
        }
    }
}

ext.sharedNpmLogic = { task, List<String> target -> 
    configure(task) {
        workingDir "$webappDir"
        group = BasePlugin.BUILD_GROUP
        if (!org.gradle.internal.os.OperatingSystem.current().isWindows()) {
            commandLine (["npm"] + target)
        } else {
            commandLine (["npm.cmd"] + target)
        }
    }
}

ext.sharedCoverageServeLogic = { task, List<String> target -> 
    configure(task) {
        workingDir "$webappDir"
        group = BasePlugin.BUILD_GROUP
        if (!org.gradle.internal.os.OperatingSystem.current().isWindows()) {
            executable "npm"
        } else {
            executable "npm.cmd"
        }

        args = ["run", "--", "ng", "serve", "--no-watch", "--no-live-reload"] + target
    }
}

evaluationDependsOn(':test-data')

task updateFixtureProducts(type: Copy) {
    def prj = project(':test-data')
    from prj.product1Zip.outputs
    from prj.product2Zip.outputs
    from prj.externalSoftwareZip.outputs

    into "${webappDir}/cypress/fixtures"

    doFirst {
        delete fileTree("${webappDir}/cypress/fixtures").matching { include "*.zip" }
    }
}

task triggerStopCoverageStandalone {
    doLast {
        println "Stop Coverage for Standalone"
    }
}

task runCoverageServerStandalone(type: com.github.psxpaul.task.ExecFork) {
    sharedCoverageServeLogic(it, ["-c", "cov-standalone"])
    waitForOutput = "Compiled successfully"
    timeout = 120
    stopAfter = triggerStopCoverageStandalone
}

task triggerStopCoverageCentral {
    doLast {
        println "Stop Coverage for Central"
    }
}

task runCoverageServerCentral(type: com.github.psxpaul.task.ExecFork) {
    sharedCoverageServeLogic(it, ["-c", "cov-central"])
    waitForOutput = "Compiled successfully"
    timeout = 120
    stopAfter = triggerStopCoverageCentral
}

task triggerStopCoverageManaged {
    doLast {
        println "Stop Coverage for Managed"
    }
}

task runCoverageServerManaged(type: com.github.psxpaul.task.ExecFork) {
    sharedCoverageServeLogic(it, ["-c", "cov-managed"])
    waitForOutput = "Compiled successfully"
    timeout = 120
    stopAfter = triggerStopCoverageManaged
}

task updateFixtures(dependsOn: [':test-data:setupDemoServer', 'updateFixtureProducts', runCoverageServerStandalone, runCoverageServerCentral, runCoverageServerManaged]) {
    // currently nothing...
}

List<String> getCypressConfig() {
    def standalonePort = project(":test-data").testServerPort
    def centralPort = project(":test-data").testServerPortCentral
    def managedPort = project(":test-data").testServerPortManaged
    return [
        "--config", "baseUrl=http://localhost:4210",
        "--env", "backendBaseUrl=https://localhost:${standalonePort}/api"
        + ",baseUrlCentral=http://localhost:4211"
        + ",backendBaseUrlCentral=https://localhost:${centralPort}/api"
        + ",baseUrlManaged=http://localhost:4212"
        + ",backendBaseUrlManaged=https://localhost:${managedPort}/api"
    ]

}

String cypressCmd() {
    if (!org.gradle.internal.os.OperatingSystem.current().isWindows()) {
        return "cypress";
    } else {
        return "cypress.cmd";
    }
}

task runCypressHeadless(type: Exec, dependsOn: updateFixtures) {
    workingDir "$webappDir"
    group = BasePlugin.BUILD_GROUP

    List<String> properties = getCypressConfig()
    if(project.hasProperty('cypressIgnoreExitValue')) {
        ignoreExitValue = true
    }
    if(project.hasProperty('cypressBrowser')) {
        properties.add('--browser')
        properties.add(project.property('cypressBrowser'))
    }
    if(project.hasProperty('cypressHeadless')) {
    	properties.add('--headless')
    }
    if(project.hasProperty('recordCypress')) {
        properties.add('--record')
        properties.add('--key')
        properties.add('a32f4a49-c18e-4942-8fb3-38928b39318e')
    }
    if(project.hasProperty('cypressParallel')) {
        properties.add('--parallel')
    }
    if(project.hasProperty('cypressGroup')) {
        properties.add('--group')
    }
    if(project.hasProperty('cypressBuildId')) {
        properties.add('--ci-build-id')
    }
    commandLine (["${webappDir}/node_modules/.bin/" + cypressCmd(), "run" ] + properties)
}

task updateDocuScreenshots(type: Copy, dependsOn: runCypressHeadless) {
    from fileTree(dir: "${webappDir}/cypress/screenshots/docu.spec.js").matching { include "*.png" }
    from fileTree(dir: "${webappDir}/cypress/screenshots/instance-group.spec.js").matching { include "*.png" }
    from fileTree(dir: "${webappDir}/cypress/screenshots/user.spec.js").matching { include "*.png" }
    from fileTree(dir: "${webappDir}/cypress/screenshots/template.spec.js").matching { include "*.png" }
    into new File(project(":doc").projectDir, "user/images")

    doLast {  
        println('Updating screenshots of user documentation done.')
    }
}

task runCypress(type: Exec, dependsOn: updateFixtures) {
    workingDir "$webappDir"
    def port = project(":test-data").testServerPort
    commandLine (["${webappDir}/node_modules/.bin/" + cypressCmd(), "open"] + getCypressConfig())
}

task runDevCypress(type: Exec) {
    workingDir "$webappDir"
    commandLine (["${webappDir}/node_modules/.bin/" + cypressCmd(), "open", 
        "--config", "baseUrl=http://localhost:4200", 
        "--env", "backendBaseUrl=https://localhost:7701/api"
        + ",baseUrlCentral=http://localhost:4201"
        + ",backendBaseUrlCentral=https://localhost:7705/api"
        + ",baseUrlManaged=http://localhost:4202"
        + ",backendBaseUrlManaged=https://localhost:7706/api"
    ])
}

// this one is required to stop the server and accumulate coverage data
task doneWithCypressHeadless(dependsOn: [':test-data:triggerStopBDeploy', triggerStopCoverageStandalone, triggerStopCoverageCentral, triggerStopCoverageManaged]) {
    doLast {
        println('Cypress Testing done...')
    }

    dependsOn runCypressHeadless
}

project(':test-data').tasks['triggerStopBDeploy'].mustRunAfter runCypressHeadless
triggerStopCoverageStandalone.mustRunAfter runCypressHeadless
triggerStopCoverageCentral.mustRunAfter runCypressHeadless
triggerStopCoverageManaged.mustRunAfter runCypressHeadless
test.dependsOn doneWithCypressHeadless

task release(type: Copy, dependsOn: runCypressHeadless) {
    from "${webappDir}/cypress/fixtures/export-test.zip"
    into new File(project(':test-data').projectDir, "bin-test-data")
    rename {
        version + ".zip"
    }

    doLast {
        println "Release seems to do well with UI tests"
    }
}

task cleanAngular(type:Delete) {
    delete "$webappDir/dist"
}

task buildAngular(type:Exec) { t ->
    inputs.dir "$webappDir/src"
    outputs.dir "$webappDir/dist"
    sharedNpmLogic(t, ["run", "--", "ng", "build", "--prod"])
	dependsOn 'installAngular'
    dependsOn 'genDtos'
}

task installAngular(type:Exec) { t ->
    inputs.file "$webappDir/package.json"
    outputs.dir "$webappDir/node_modules"
    sharedNpmLogic(t, ["install"])
}

evaluationDependsOn(':doc')
task copyUserDoc(type:Copy, dependsOn:':doc:userDoc') {
    from tasks.getByPath(':doc:userDoc').outputs
    into "$webappDir/dist/webapp/assets/doc"
}

task genDtos(type: cz.habarta.typescript.generator.gradle.GenerateTask, dependsOn: compileJava) {
    jsonLibrary = 'jackson2'
    classes = [
        // Descriptors
        'io.bdeploy.interfaces.descriptor.application.ApplicationDescriptor',
        'io.bdeploy.interfaces.descriptor.client.ClickAndStartDescriptor',
        'io.bdeploy.interfaces.descriptor.template.InstanceTemplateDescriptor',
        'io.bdeploy.interfaces.descriptor.template.ApplicationTemplateDescriptor',
        // Configurations and their DTOs
        'io.bdeploy.interfaces.configuration.SettingsConfiguration',
        'io.bdeploy.interfaces.configuration.dcu.ApplicationConfiguration',
        'io.bdeploy.interfaces.configuration.pcu.ProcessStatusDto',
        'io.bdeploy.interfaces.configuration.instance.InstanceConfiguration',
        'io.bdeploy.interfaces.configuration.instance.InstanceGroupConfiguration',
        'io.bdeploy.interfaces.configuration.instance.InstanceGroupPermissionDto',
        'io.bdeploy.interfaces.configuration.instance.InstanceNodeConfiguration',
        'io.bdeploy.interfaces.configuration.instance.SoftwareRepositoryConfiguration',
        'io.bdeploy.interfaces.configuration.instance.InstanceConfigurationDto',
        'io.bdeploy.interfaces.configuration.instance.FileStatusDto',
        // UI only DTOs
        'io.bdeploy.ui.dto.ApplicationDto',
        'io.bdeploy.ui.dto.AuditLogDto',
        'io.bdeploy.ui.dto.ClientApplicationDto',
        'io.bdeploy.ui.dto.InstanceDto',
        'io.bdeploy.ui.dto.InstanceClientAppsDto',
        'io.bdeploy.ui.dto.InstanceNodeConfigurationListDto',
        'io.bdeploy.ui.dto.ProductDto',
        'io.bdeploy.ui.dto.HiveEntryDto',
        'io.bdeploy.ui.dto.InstanceVersionDto',
        'io.bdeploy.ui.dto.StringEntryChunkDto',
        'io.bdeploy.ui.dto.LauncherDto',
        'io.bdeploy.ui.dto.InstanceManifestHistoryDto',
        'io.bdeploy.ui.dto.InstanceUpdateEventDto',
        'io.bdeploy.ui.dto.ConfigFileDto',
        'io.bdeploy.ui.dto.BackendInfoDto',
        'io.bdeploy.ui.dto.ProductTransferDto',
        // Other, generic
        'io.bdeploy.common.Version',
        'io.bdeploy.common.ActivitySnapshot',
        'io.bdeploy.interfaces.cleanup.CleanupGroup',
        'io.bdeploy.interfaces.directory.InstanceDirectory',
        'io.bdeploy.interfaces.minion.MinionStatusDto',
        'io.bdeploy.interfaces.manifest.state.InstanceStateRecord',
        'io.bdeploy.interfaces.UserInfo',
        'io.bdeploy.interfaces.UserChangePasswordDto',
        'io.bdeploy.interfaces.manifest.managed.ManagedMasterDto',
        'io.bdeploy.interfaces.plugin.PluginInfoDto',
        'io.bdeploy.jersey.ws.WebSocketInitDto',
        'io.bdeploy.api.remote.v1.dto.CredentialsApi',
        // Metrics
        'io.bdeploy.jersey.resources.JerseyMetricsResource$MetricBundle',
        'io.bdeploy.common.metrics.Metrics$MetricGroup',
        'io.bdeploy.jersey.monitoring.JerseyServerMonitoringDto',
    ]
    customTypeMappings = [
        'java.net.URI:string',
        'java.time.Instant:number'
    ]
    customTypeNaming = [
        'io.bdeploy.bhive.model.Manifest$Key:ManifestKey',
        'io.bdeploy.bhive.model.Tree$EntryType:TreeEntryType'
    ]
    excludeClasses = [
        'java.lang.Comparable',
        'java.io.Serializable',
    ]
    outputFileType = 'implementationFile'
    outputKind = 'module'
    mapEnum = 'asEnum'
    nonConstEnums = true
    jsonLibrary = 'jackson2'
    noFileComment = true

    def cfg = new cz.habarta.typescript.generator.Jackson2Configuration();
    cfg.fieldVisibility = com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility.ANY;
    cfg.getterVisibility = com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility.NONE;
    cfg.isGetterVisibility = com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility.NONE;
    cfg.setterVisibility = com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility.NONE;

    jackson2Configuration = cfg

    outputFile = "${buildDir}/gen.dtos.tmp.ts"

    doLast {
        def outputFile = "${webappDir}/src/app/models/gen.dtos.ts"
        def tmpOutputFile = "${buildDir}/gen.dtos.tmp.ts"

        if(!file(outputFile).exists() || !file(outputFile).text.equals(file(tmpOutputFile).text)) {
            delete file(outputFile)
            file(tmpOutputFile).renameTo(file(outputFile))
        } else {
            println("No changes in generated DTO, skipping update")
        }
    }
}

sonarqube {
    properties {
        properties["sonar.sources"] += "${projectDir}/webapp/src"
        property "sonar.javascript.lcov.reportPaths", "${projectDir}/webapp/coverage/lcov.info"
    }
}

processResources.dependsOn "buildAngular"
processResources.dependsOn "copyUserDoc"
clean.dependsOn "cleanAngular"

