import okhttp3.OkHttpClient
import java.util.concurrent.TimeUnit

plugins {
    id 'base'
    id "com.github.psxpaul.execfork" version "0.2.1"
    id "de.undercouch.download" version "5.3.0"
    id "jacoco"
    id "com.github.breadmoirai.github-release" version "2.4.1"
}

ext {
    testServerRoot = "${buildDir}/test-root"
    testServerHost = "localhost"
    testServerPort = 7711

    testServerRootCentral = "${buildDir}/test-root-central"
    testServerRootManaged = "${buildDir}/test-root-managed"
    testServerPortCentral = 7715
    testServerPortManaged = 7716

    _testBinVersions = new File(projectDir, "test.versions") as String[]

    getTestBinVersions = {
        result = []
        _testBinVersions.each { 
            if(it.empty) {
                return;
            }
            def dataFile = file("${projectDir}/bin-test-data/${it}.zip")
            if(!dataFile.exists()) {
                println "WARNING: Skipping test server for " + it + ", file does not exist: " + dataFile
            } else {
                result.add(it)
            }
        }
        return result;
    }

    bdeployBaseUrl = "https://github.com/bdeployteam/bdeploy/releases/download/"
}

task printTestVersions {
    doLast {
        getTestBinVersions().each {
            println "Version: " + it;
        }
    }
}

task addTestVersion {
    doFirst {
        if(!project.hasProperty('addVersion')) {
            throw new RuntimeException("Need to set property addVersion");
        }
    }
    doLast {
        new File(projectDir, "/test.versions").text += project.getProperty('addVersion') + '\n';
    }
}

evaluationDependsOn(':minion')

int randomServerPort() {
    new ServerSocket(0).withCloseable {
        return it.getLocalPort();
    }
}

void createProductTasks(String taskName, String prod) {
    task "${taskName}" (type: Zip) {
        from fileTree(dir: "${projectDir}/${prod}")
        archiveName "${prod}-direct.zip"
        destinationDir file("${buildDir}/distribution/")
        inputs.dir file("${projectDir}/${prod}")
    }

    build {
        dependsOn "${taskName}"
    }
}

void setupBDeployEnv(ProcessForkOptions options, String root) {
    options.environment += [
        HOSTNAME: testServerHost,
        BDEPLOY_ROOT: root,
    ]
}

void setupBDeployRemoteEnv(ProcessForkOptions options, String root, int port) {
    setupBDeployEnv(options, root)
    options.environment += [
        BDEPLOY_REMOTE: "https://localhost:${port}/api",
        BDEPLOY_TOKENFILE: "${root}/test-token.txt",
        REMOTE_BHIVE: "Test"
    ]
}

void setupBDeployJavaExec(JavaExec je, String root, int port) {
    je.main = project(":minion").mainClassName
    je.classpath = project(":minion").sourceSets.main.runtimeClasspath
    if(root != null) {
        setupBDeployRemoteEnv(je, root, port)
    }
}

task triggerStopBDeploy() {
    doLast {
        println("Stopped BDeploy Server")
    }
}

void createServerTasks(String name, String root, int port) {
    task "initTestBDeploy${name}"(type: JavaExec ) {
        setupBDeployJavaExec(it, root, port);

        def taskName = "";
        if (org.gradle.internal.os.OperatingSystem.current().isWindows()) {
            taskName = "win64DistZip"
        } else if (org.gradle.internal.os.OperatingSystem.current().isLinux()) {
            taskName = "linux64DistZip"
        } else if (org.gradle.internal.os.OperatingSystem.current().isMacOsX()) {
            taskName = "mac64DistZip"
        }
        dependsOn ':minion:'+taskName

        doFirst() {
            delete "${root}"
        }

        if(name.equals("Central") || name.equals("Managed")) {
            // save some time on startup...
            args = [ "init", "--port=${port}", "--dist=ignore", "--mode=" + name, "--initUser=admin", "--initPassword=admin" ]
        } else {
            args = [ "init", "--port=${port}", "--dist="+project(':minion').tasks[taskName].outputs.files[0], "--mode=standalone", "--initUser=admin", "--initPassword=admin" ]
        }
    }

    task "startTestBDeploy${name}"(type: com.github.psxpaul.task.JavaExecFork, dependsOn: "initTestBDeploy${name}") {
        setupBDeployEnv(it, root)
        main = project(":minion").mainClassName
        classpath = project(":minion").sourceSets.main.runtimeClasspath
        args = [ "start", "--allowCors", "--consoleLog" ]
        jvmArgs = [ '-Xmx128M' ] // all tests must fit :)
        waitForPort = port
        stopAfter = triggerStopBDeploy
    }
}

createServerTasks("", testServerRoot, testServerPort);
if(!project.hasProperty('cypressNoCentral')) {
    createServerTasks("Central", testServerRootCentral, testServerPortCentral);
    createServerTasks("Managed", testServerRootManaged, testServerPortManaged);
}

task checkTestBDeploy(type: JavaExec, dependsOn: startTestBDeploy) {
    setupBDeployJavaExec(it, testServerRoot, testServerPort);
    args = [ "remote-master", "--minions" ]
}

task cleanExternalSoftwareHive(type: Delete) {
    delete "${buildDir}/external-software-hive"
}

task initExtSoftwareHive(type: JavaExec, dependsOn: cleanExternalSoftwareHive) {
    setupBDeployJavaExec(it, testServerRoot, testServerPort);
    args = [ "bhive", "init", "--hive=${buildDir}/external-software-hive" ]
}

// now define the dynamic tasks for each operating system
createExternalSoftwareTasks("windows")
createExternalSoftwareTasks("linux")
// createExternalSoftwareTasks("mac")

void createExternalSoftwareTasks(String os) {
    def osUpper = os.substring(0,1).toUpperCase() + os.substring(1);
    def hive = "${buildDir}/external-software-hive";
    def source = "${projectDir}/external-software/${os}"

    task "externalSoftware${osUpper}" (type: JavaExec, dependsOn: "initExtSoftwareHive") {
        setupBDeployJavaExec(it, testServerRoot, testServerPort);
        args = [ "bhive", "import", "--hive=${hive}", "--source=${source}", "--manifest=external/software/${os}:v1.0.0" ]
    }

    build {
        dependsOn "externalSoftware${osUpper}"
    }
}

task externalSoftwareZip(type: Zip, dependsOn: [externalSoftwareWindows, externalSoftwareLinux]) {
    archiveFileName = "external-software-hive.zip"
    destinationDir = file("${buildDir}/distribution/")
    
    from "${buildDir}/external-software-hive"
}

// now define the dynamic tasks for each product
createProductTasks("product1Zip", "test-product-1")
createProductTasks("product2Zip", "test-product-2")
createProductTasks("product3Zip", "chat-product-1")
createProductTasks("externalSoftware2Zip","external-software-2-raw")

// now the tasks for binary (upgrade) tests
task releaseTest() {
    doFirst {
        // container to depend on all migration tests.
        if(project(":minion").mac64DistZip.enabled && !org.gradle.internal.os.OperatingSystem.current().isMacOsX()) {
            throw new IllegalStateException("Release tests not supported with MAC support enabled right now")
        }
    }
}

task verifyBDeployExe(type: JavaExec) {
    setupBDeployJavaExec(it, null, 0);
    args = [ "verify-signature", "--executable=" + project(":launcher").projectDir + "/src/win64/dist/BDeploy.exe" ]
}

task verifyFileAssocExe(type: JavaExec) {
    setupBDeployJavaExec(it, null, 0);
    args = [ "verify-signature", "--executable=" + project(":launcher").projectDir + "/src/win64/dist/FileAssoc.exe" ]
}

task verifyInstallerBin(type: JavaExec) {
    setupBDeployJavaExec(it, null, 0);
    args = [ "verify-signature", "--executable=" + project(":launcher").projectDir + "/src/win64/dist/bin/Installer.bin" ]
}

task verifyBinaries() {
    dependsOn verifyBDeployExe
    dependsOn verifyFileAssocExe
    dependsOn verifyInstallerBin
}

task release(dependsOn: [releaseTest, verifyBinaries]) {
    doLast {
        println "Release seems to do well with upgrades..."
    }
}

evaluationDependsOn(':api')
githubRelease {
    if(project.hasProperty('githubToken')) {
        token project.getProperty('githubToken')
    }
    owner 'bdeployteam'
    repo 'bdeploy'
    tagName "v${version}"
    releaseName "Release ${version}"
    targetCommitish "master"

    releaseAssets.from(project(":minion").linux64DistZip)
    releaseAssets.from(project(":minion").win64DistZip)
    releaseAssets.from(project(":api").shadowJar)
    releaseAssets.from(fileTree(project(":api").resolve.outputDir))
    releaseAssets.from(project(":test-data").product1Zip)
    releaseAssets.from(project(":test-data").product2Zip)
    releaseAssets.from(project(":test-data").product3Zip)

    // increase read and write timeouts as the files are rather large :)
    client new OkHttpClient.Builder().readTimeout(10, TimeUnit.MINUTES).writeTimeout(10, TimeUnit.MINUTES).build();
}

void setupBinServerTasks(String version) {
    def key = version.replace('.', '_')
    def osName = "win64";
    if (org.gradle.internal.os.OperatingSystem.current().isLinux()) {
        osName = "linux64";
    } else if(org.gradle.internal.os.OperatingSystem.current().isMacOsX()) {
        osName = "mac64";
    }
    def fileKey = "bdeploy-" + osName + "-" + version;
    def binFile = new File(buildDir, "bin-dist_${key}/" + fileKey + "/bin/bdeploy")
    if (org.gradle.internal.os.OperatingSystem.current().isWindows()) {
        binFile = file(binFile.toString() + ".bat")
    }
    def port = randomServerPort();

    def setupTask = { e ->
        e.executable binFile
        setupBDeployRemoteEnv(e, "${buildDir}/bin-root_${key}", port)
    }

    task "downloadBinaries_${key}" (type: Download) {
        src bdeployBaseUrl + "v" + version + "/" + fileKey + ".zip"
        dest new File(buildDir, version + "-bin.zip")
        onlyIfModified true
    }

    task "unzipBinaries_${key}" (type: Copy, dependsOn: "downloadBinaries_${key}") {
        from zipTree(tasks["downloadBinaries_${key}"].dest)
        into new File(buildDir, "bin-dist_${key}")

        doFirst {
            delete "${buildDir}/bin-dist_${key}"
        }
    }

    task "binInitTestBDeploy_${key}" (type: Exec, dependsOn: "unzipBinaries_${key}") {
        setupTask(it)
        doFirst {
            delete "${buildDir}/bin-root_${key}"
        }

        if(!key.startsWith('1')) {
            args = [ "init", "--port=${port}", "--dist=ignore", "--mode=standalone", "--initUser=admin", "--initPassword=admin" ]
        } else {
            args = [ "init", "--port=${port}", "--dist=ignore", "--mode=standalone" ]
        }
    }

    task "binTriggerStopBDeploy_${key}"() {
        doLast {
            println("Stopped BDeploy Server (" + version + ")")
        }
    }

    task "binStartTestBDeploy_${key}" (type: com.github.psxpaul.task.ExecFork, dependsOn: "binInitTestBDeploy_${key}") {
        executable binFile
        setupBDeployEnv(it, "${buildDir}/bin-root_${key}")
        args = [ "master", "--consoleLog" ] // TODO: this should be 'start' but this is only supported by 3.3.0 or newer.
        waitForPort = port
        stopAfter = tasks["binTriggerStopBDeploy_${key}"]
        standardOutput = new File("${buildDir}/out_${key}.txt")
    }

    if(key.startsWith("1")) {
        task "binAddTestBDeployUser_${key}"(type: Exec, dependsOn: "binStartTestBDeploy_${key}") {
            setupTask(it)
            args = [ "user", "--add=admin", "--password=admin", "--admin", "--description=Automated Test User" ]
        }
    }

    task "binCheckTestBDeploy_${key}"(type: Exec) {
        if(key.startsWith("1")) {
            dependsOn "binAddTestBDeployUser_${key}"
        } else {
            dependsOn "binStartTestBDeploy_${key}"
        }
        setupTask(it)
        args = [ "remote-master", "--minions" ]
    }

    task "binCreateInstanceGroup_${key}" (type: Exec, dependsOn: "binCheckTestBDeploy_${key}") {
        setupTask(it)
        args = [ "remote-group", "--create=Test", "--description=Automatic Test" ]
    }

    ["1", "2"].each { prodNum ->
        task "binDownloadProd${prodNum}_${key}" (type: Download) {
            src bdeployBaseUrl + "v" + version + "/test-product-" + prodNum + "-direct.zip"
            dest new File(buildDir, version + "-prod" + prodNum + ".zip")
            onlyIfModified true
        }

        task "binUnzipProd${prodNum}_${key}" (type: Copy, dependsOn: "binDownloadProd${prodNum}_${key}") {
            from zipTree(tasks["binDownloadProd${prodNum}_${key}"].dest)
            into new File(buildDir, "prod-dist-" + prodNum)

            doFirst {
                delete "${buildDir}/prod-dist-" + prodNum
            }
        }

        // old versions don't have the command, new versions require hive to be init'ed - this is a compromise (use the current version to init).
        task "binInitProdHive${prodNum}_${key}" (type: JavaExec, dependsOn: [ "binCreateInstanceGroup_${key}", "binUnzipProd${prodNum}_${key}" ]) {
            setupBDeployJavaExec(it, testServerRoot, testServerPort);
            doFirst {
                delete "${buildDir}/pushTmp${prodNum}"
            }
            args = [ "bhive", "init", "--hive=${buildDir}/pushTmp${prodNum}" ]
        }

        task "binImportProd${prodNum}_${key}" (type: Exec, dependsOn: "binInitProdHive${prodNum}_${key}") {
            setupTask(it)
            outputs.upToDateWhen { false }
            args = ["product", "--hive=${buildDir}/pushTmp${prodNum}", "--import=${buildDir}/prod-dist-${prodNum}", "--push"]
        }
    }

    if(!(key.startsWith('1') || key.startsWith('2') || key.startsWith('3_0'))) {
        task "binCreateTestInstance_${key}" (type: Exec, dependsOn: "binImportProd2_${key}") {
            setupTask(it)
            args = [ "remote-instance", "--create=TestInstance", "--description=XX", "--uuid=aaa-bbb-ccc", "--purpose=TEST", "--product=io.bdeploy/demo/product", "--productVersion=2.0.0" ]
        }
    }

    task "binImportTestData_${key}" (type: Exec, dependsOn: "binImportProd2_${key}") {
        setupTask(it)
        if(key.startsWith('1') || key.startsWith('2') || key.startsWith('3_0')) {
            args = [ "instance", "--importFrom=${projectDir}/bin-test-data/${version}.zip", "--hive=${buildDir}/bin-root_${key}/storage/Test" ]
        } else {
            dependsOn "binCreateTestInstance_${key}"
            args = [ "remote-instance", "--importFrom=${projectDir}/bin-test-data/${version}.zip", "--uuid=aaa-bbb-ccc" ]
        }
    }

    task "binSetupDemoServer_${key}"() {
        dependsOn(
            "binImportProd1_${key}",
            "binImportProd2_${key}",
            "binImportTestData_${key}"
        )

        doFirst {
            println("----------------------------------------------------------------------------------------")
            println("Successfully started demo server (" + version + "). Point your browser to https://localhost:${port}.")
            println("User and password for the demo server are 'admin' and 'admin'.")
            println("----------------------------------------------------------------------------------------")
        }
    }

    task "binMigrateToCurrent_${key}"(type: Exec, dependsOn: "binSetupDemoServer_${key}") {
        def currentDistTask = project(":minion").win64DistZip
        if(org.gradle.internal.os.OperatingSystem.current().isLinux()) {
            currentDistTask = project(":minion").linux64DistZip
        } else if(org.gradle.internal.os.OperatingSystem.current().isMacOsX()) {
            currentDistTask = project(":minion").mac64DistZip
        }

        dependsOn currentDistTask
        setupTask(it)

        args = ["remote-master", "--yes", "--update=" + currentDistTask.outputs.files[0] ]
    }

    task "binWaitForMigrateToCurrent_${key}" (dependsOn: "binMigrateToCurrent_${key}") {
        doLast {
            // check the output file for the output we expect
            println "waiting for migration to proceed: " + System.currentTimeMillis();
            def ok = false;
            def rqFound = false;
            def search = "Started Version " + project.version.replaceAll('SNAPSHOT', rootProject.buildDate)
            for(int i = 0; i < 1000; ++i) {
                String check = file("${buildDir}/out_${key}.txt").text

                def exc = (check =~ /java\.lang\..*Exception/)
                if(exc.size() > 0) {
                    throw new RuntimeException("Upgrade log contains exceptions. Output: " + check);
                }

                if(!rqFound) {
                    // can be "update request" (<4.3.0) or "restart request" (>4.3.0)
                    def rq = (check =~ /Minion signalled (update|restart) request/)
                    if(rq.size() == 1) {
                        println "Server received update request"
                        rqFound = true;
                    }
                }

                if(rqFound) {
                    def match = (check =~ search)
                    if(match.find()) {
                        println "Server successfully restarted after update"
                        ok = true;
                        break;
                    }
                }
                println "Waiting... " + System.currentTimeMillis();
                sleep(2000);
            }

            if(!ok) {
                println "Could not await update: " + System.currentTimeMillis();
                String check = file("${buildDir}/out_${key}.txt").text
                throw new RuntimeException("Upgrade to current version failed, could not find '" + search + "'. Output: " + check);
            }
        }
    }

    releaseTest.dependsOn "binWaitForMigrateToCurrent_${key}"

    // dependencies are defined by the tasks. This does not guarantee an execution order. we need to manually define it
    // to be able to run multiple upgrade tests after each other.
    tasks["binStartTestBDeploy_${key}"].mustRunAfter("binInitTestBDeploy_${key}")
    if(key.startsWith("1")) {
        tasks["binAddTestBDeployUser_${key}"].mustRunAfter("binStartTestBDeploy_${key}")
        tasks["binCheckTestBDeploy_${key}"].mustRunAfter("binAddTestBDeployUser_${key}")
    } else {
        tasks["binCheckTestBDeploy_${key}"].mustRunAfter("binStartTestBDeploy_${key}")
    }
    tasks["binCreateInstanceGroup_${key}"].mustRunAfter("binCheckTestBDeploy_${key}")
    tasks["binDownloadProd1_${key}"].mustRunAfter("binCreateInstanceGroup_${key}")
    tasks["binDownloadProd2_${key}"].mustRunAfter("binCreateInstanceGroup_${key}")
    tasks["binUnzipProd1_${key}"].mustRunAfter("binDownloadProd1_${key}")
    tasks["binUnzipProd2_${key}"].mustRunAfter("binDownloadProd2_${key}")
    tasks["binImportProd1_${key}"].mustRunAfter("binUnzipProd1_${key}")
    tasks["binImportProd2_${key}"].mustRunAfter("binUnzipProd2_${key}")
    if(!(key.startsWith('1') || key.startsWith('2') || key.startsWith('3_0'))) {
        tasks["binCreateTestInstance_${key}"].mustRunAfter("binUnzipProd2_${key}")
    }
    tasks["binImportTestData_${key}"].mustRunAfter("binImportProd2_${key}")
    tasks["binSetupDemoServer_${key}"].mustRunAfter("binImportProd2_${key}")
    tasks["binMigrateToCurrent_${key}"].mustRunAfter("binSetupDemoServer_${key}")
    tasks["binWaitForMigrateToCurrent_${key}"].mustRunAfter("binMigrateToCurrent_${key}")
    tasks["binWaitForMigrateToCurrent_${key}"].finalizedBy("binTriggerStopBDeploy_${key}")

    task "binRunDemoServer_${key}" (dependsOn: "binSetupDemoServer_${key}") {
        doLast() {
            // no println will work in doLast, it will appear only AFTER the question is answered.
            def userInput = services.get(org.gradle.api.internal.tasks.userinput.UserInputHandler)
            def answer = userInput.askQuestion("Enter any value (or press enter) to stop the server", "Stop");
        }
    }
}

getTestBinVersions().each { setupBinServerTasks(it) }

// coverage for the rest of the tasks
jacoco {
    applyTo initTestBDeploy
    applyTo checkTestBDeploy
    applyTo startTestBDeploy
    if(!project.hasProperty('cypressNoCentral')) {
        applyTo startTestBDeployCentral
        applyTo startTestBDeployManaged
    }
}

// now all tasks that depend on any of the generated tasks
task setupDemoServer() {
    dependsOn checkTestBDeploy
    if(!project.hasProperty('cypressNoCentral')) {
        dependsOn startTestBDeployCentral
        dependsOn startTestBDeployManaged
    }

    doFirst() {
        println("----------------------------------------------------------------------------------------")
        println("Successfully started demo server. Point your browser to:")
        println("  https://localhost:${testServerPort} - STANDALONE Demo Server")
        if(!project.hasProperty('cypressNoCentral')) {
            println("  https://localhost:${testServerPortCentral} - CENTRAL Demo Server")
            println("  https://localhost:${testServerPortManaged} - MANAGED Demo Server")
        }
        println("User and password for the demo server(s) are 'admin' and 'admin'.")
        println("NOTE: that cookies are hostname based, so logging in to one will log out on any other");
        println("      server running on the same hostname.");
        println("----------------------------------------------------------------------------------------")
    }
}

task runDemoServer(dependsOn: setupDemoServer) {
    doLast() {
        // no println will work in doLast, it will appear only AFTER the question is answered.
        def userInput = services.get(org.gradle.api.internal.tasks.userinput.UserInputHandler)
        def answer = userInput.askQuestion("Enter any value (or press enter) to stop the server", "Stop");
    }
}

