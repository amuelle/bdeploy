plugins {
    id 'base'
    // need 0.1.12+ on update to gradle 5.6.0+
    id "com.github.psxpaul.execfork" version "0.1.12"
    id "de.undercouch.download" version "4.0.1"
    id "jacoco"
}

ext {
    testServerRoot = "${buildDir}/test-root"
    testServerHost = InetAddress.getLocalHost().getCanonicalHostName()
    testServerPort = randomServerPort()
    _testBinVersions = [ "1.2.1", "1.3.0", "1.3.1" ]

    if (org.gradle.internal.os.OperatingSystem.current().isWindows()) {
        // only test latest for now. Windows binaries are not stopped for some reason when killing the bat.
        _testBinVersions = [ _testBinVersions[_testBinVersions.size() - 1] ];
    }

    getTestBinVersions = {
        result = []
        _testBinVersions.each { 
            def dataFile = file("${projectDir}/bin-test-data/${it}.zip")
            if(!dataFile.exists()) {
                println "WARNING: Skipping test server for " + it + ", file does not exist: " + dataFile
            } else {
                result.add(it)
            }
        }
        return result;
    }

    bdeployBaseUrl = "https://github.com/bdeployteam/bdeploy/releases/download/"
}

evaluationDependsOn(':minion')

int randomServerPort() {
    new ServerSocket(0).withCloseable {
        return it.getLocalPort();
    }
}

void createProductTasks(String prodNum) {
    task "product${prodNum}Zip" (type: Zip) {
        from fileTree(dir: "${projectDir}/test-product-${prodNum}")
        archiveName "test-product-${prodNum}-direct.zip"
        destinationDir file("${buildDir}/distribution/")
        inputs.dir file("${projectDir}/test-product-${prodNum}")
    }

    build {
        dependsOn "product${prodNum}Zip"
    }
}

void setupBDeployEnv(ProcessForkOptions options, String testServerRoot) {
    options.environment += [
        HOSTNAME: testServerHost,
        BDEPLOY_ROOT: testServerRoot,
    ]
}

void setupBDeployRemoteEnv(ProcessForkOptions options, String testServerRoot) {
    setupBDeployEnv(options, testServerRoot)
    options.environment += [
        BDEPLOY_REMOTE: "https://localhost:${testServerPort}/api",
        BDEPLOY_TOKENFILE: "${testServerRoot}/test-token.txt",
        REMOTE_BHIVE: "Test"
    ]
}

void setupBDeployJavaExec(JavaExec je) {
    je.main = project(":minion").mainClassName
    je.classpath = project(":minion").sourceSets.main.runtimeClasspath
    setupBDeployRemoteEnv(je, testServerRoot)
}

task initTestBDeploy(type: JavaExec ) {
    def taskName = "";
    if (org.gradle.internal.os.OperatingSystem.current().isWindows()) {
        taskName = "win64DistZip"
    } else if (org.gradle.internal.os.OperatingSystem.current().isLinux()) {
        taskName = "linux64DistZip"
    } else if (org.gradle.internal.os.OperatingSystem.current().isMacOsX()) {
        taskName = "mac64DistZip"
    }
    dependsOn ':minion:'+taskName

    doFirst() {
        delete "${testServerRoot}"
    }

    args = [ "init", "--port=${testServerPort}", "--dist="+project(':minion').tasks[taskName].outputs.files[0] ]
}

task triggerStopBDeploy() {
    doLast {
        println("Stopped BDeploy Server")
    }
}

task startTestBDeploy(type: com.github.psxpaul.task.JavaExecFork, dependsOn: initTestBDeploy) {
    setupBDeployEnv(it, testServerRoot)
    main = project(":minion").mainClassName
    classpath = project(":minion").sourceSets.main.runtimeClasspath
    args = [ "master" ]
    waitForPort = testServerPort
    stopAfter = triggerStopBDeploy
}

task addTestBDeployUser(type: JavaExec, dependsOn: startTestBDeploy) {
    args = [ "user", "--add=admin", "--password=admin", "--description=Automated Test User" ]
}

task checkTestBDeploy(type: JavaExec, dependsOn: addTestBDeployUser) {
    args = [ "remote-master", "--minions" ]
}

task cleanExternalSoftwareHive(type: Delete) {
    delete "${buildDir}/external-software-hive"
}

// now define the dynamic tasks for each operating system
createExternalSoftwareTasks("windows")
createExternalSoftwareTasks("linux")
// createExternalSoftwareTasks("mac")

void createExternalSoftwareTasks(String os) {
    def osUpper = os.substring(0,1).toUpperCase() + os.substring(1);
    def hive = "${buildDir}/external-software-hive";
    def source = "${projectDir}/external-software/${os}"
    
    task "externalSoftware${osUpper}" (type: JavaExec, dependsOn: cleanExternalSoftwareHive) {
         args = [ "bhive", "import", "--hive=${hive}", "--source=${source}", "--manifest=external/software/${os}:v1.0.0" ]
    }

    build {
        dependsOn "externalSoftware${osUpper}"
    }
}

task externalSoftwareZip(type: Zip, dependsOn: [externalSoftwareWindows, externalSoftwareLinux]) {
    archiveFileName = "external-software-hive.zip"
    destinationDir = file("${buildDir}/distribution/")
    
    from "${buildDir}/external-software-hive"
}

// now define the dynamic tasks for each product
createProductTasks("1")
createProductTasks("2")

// now the tasks for binary (upgrade) tests
task releaseTest() {
    // container to depend on all migration tests.
    if(project(":minion").mac64DistZip.enabled && !org.gradle.internal.os.OperatingSystem.current().isMacOsX()) {
        throw new IllegalStateException("Release tests not supported with MAC support enabled right now")
    }
}

task release(dependsOn: releaseTest) {
    doLast {
        println "Release seems to do well with upgrades..."
    }
}

void setupBinServerTasks(String version) {
    def key = version.replace('.', '_')
    def osName = "win64";
    if (org.gradle.internal.os.OperatingSystem.current().isLinux()) {
        osName = "linux64";
    } else if(org.gradle.internal.os.OperatingSystem.current().isMacOsX()) {
        osName = "mac64";
    }
    def fileKey = "bdeploy-" + osName + "-" + version;
    def binFile = new File(buildDir, "bin-dist_${key}/" + fileKey + "/bin/bdeploy")
    if (org.gradle.internal.os.OperatingSystem.current().isWindows()) {
        binFile = file(binFile.toString() + ".bat")
    }

    def setupTask = { e ->
        e.executable binFile
        setupBDeployRemoteEnv(e, "${buildDir}/bin-root_${key}")
    }

    task "downloadBinaries_${key}" (type: Download) {
        src bdeployBaseUrl + "v" + version + "/" + fileKey + ".zip"
        dest new File(buildDir, version + "-bin.zip")
        onlyIfModified true
    }

    task "unzipBinaries_${key}" (type: Copy, dependsOn: "downloadBinaries_${key}") {
        from zipTree(tasks["downloadBinaries_${key}"].dest)
        into new File(buildDir, "bin-dist_${key}")

        doFirst {
            delete "${buildDir}/bin-dist_${key}"
        }
    }

    task "binInitTestBDeploy_${key}" (type: Exec, dependsOn: "unzipBinaries_${key}") {
        setupTask(it)
        doFirst {
            delete "${buildDir}/bin-root_${key}"
        }

        args = [ "init", "--port=${testServerPort}", "--dist=ignore" ]
    }

    task "binTriggerStopBDeploy_${key}"() {
        doLast {
            println("Stopped BDeploy Server (" + version + ")")
        }
    }

    task "binStartTestBDeploy_${key}" (type: com.github.psxpaul.task.ExecFork, dependsOn: "binInitTestBDeploy_${key}") {
        executable binFile
        setupBDeployEnv(it, "${buildDir}/bin-root_${key}")
        args = [ "master" ]
        waitForPort = testServerPort
        stopAfter = tasks["binTriggerStopBDeploy_${key}"]
        standardOutput = "${buildDir}/out_${key}.txt"
    }

    task "binAddTestBDeployUser_${key}"(type: Exec, dependsOn: "binStartTestBDeploy_${key}") {
        setupTask(it)
        args = [ "user", "--add=admin", "--password=admin", "--description=Automated Test User" ]
    }

    task "binCheckTestBDeploy_${key}"(type: Exec, dependsOn: "binAddTestBDeployUser_${key}") {
        setupTask(it)
        args = [ "remote-master", "--minions" ]
    }

    task "binCreateInstanceGroup_${key}" (type: Exec, dependsOn: "binCheckTestBDeploy_${key}") {
        setupTask(it)
        args = [ "remote-group", "--create=Test", "--description=Automatic Test" ]
    }

    ["1", "2"].each { prodNum ->
        task "binDownloadProd${prodNum}_${key}" (type: Download) {
            src bdeployBaseUrl + "v" + version + "/test-product-" + prodNum + "-direct.zip"
            dest new File(buildDir, version + "-prod" + prodNum + ".zip")
            onlyIfModified true
        }

        task "binUnzipProd${prodNum}_${key}" (type: Copy, dependsOn: "binDownloadProd${prodNum}_${key}") {
            from zipTree(tasks["binDownloadProd${prodNum}_${key}"].dest)
            into new File(buildDir, "prod-dist-" + prodNum)

            doFirst {
                delete "${buildDir}/prod-dist-" + prodNum
            }
        }

        task "binImportProd${prodNum}_${key}" (type: Exec, dependsOn: [ "binCreateInstanceGroup_${key}", "binUnzipProd${prodNum}_${key}" ]) {
            setupTask(it)
            doFirst {
                delete "${buildDir}/pushTmp${prodNum}"
            }
            outputs.upToDateWhen { false }
            args = ["product", "--hive=${buildDir}/pushTmp${prodNum}", "--import=${buildDir}/prod-dist-${prodNum}", "--push"]
        }
    }

    task "binImportTestData_${key}" (type: Exec, dependsOn: "binImportProd2_${key}") {
        setupTask(it)
        args = [ "instance", "--importFrom=${projectDir}/bin-test-data/${version}.zip", "--hive=${buildDir}/bin-root_${key}/storage/Test" ]
    }

    task "binSetupDemoServer_${key}"() {
        dependsOn(
            "binImportProd1_${key}",
            "binImportProd2_${key}",
            "binImportTestData_${key}"
        )

        doFirst {
            println("----------------------------------------------------------------------------------------")
            println("Successfully started demo server (" + version + "). Point your browser to https://localhost:${testServerPort}.")
            println("User and password for the demo server are 'admin' and 'admin'.")
            println("----------------------------------------------------------------------------------------")
        }
    }

    task "binMigrateToCurrent_${key}"(type: Exec, dependsOn: "binSetupDemoServer_${key}") {
        def currentDistTask = project(":minion").win64DistZip
        if(org.gradle.internal.os.OperatingSystem.current().isLinux()) {
            currentDistTask = project(":minion").linux64DistZip
        } else if(org.gradle.internal.os.OperatingSystem.current().isMacOsX()) {
            currentDistTask = project(":minion").mac64DistZip
        }

        dependsOn currentDistTask
        setupTask(it)

        args = ["remote-master", "--yes", "--update=" + currentDistTask.outputs.files[0] ]
    }

    task "binWaitForMigrateToCurrent_${key}" (dependsOn: "binMigrateToCurrent_${key}") {
        doLast {
            // check the output file for the output we expect
            println "waiting for migration to proceed"
            def ok = false;
            def rqFound = false;
            for(int i = 0; i < 1000; ++i) {
                String check = file("${buildDir}/out_${key}.txt").text

                def exc = (check =~ /java\.lang\..*Exception/)
                if(exc.size() > 0) {
                    throw new RuntimeException("Upgrade log contains Exceptions!");
                }

                if(!rqFound) {
                    def rq = (check =~ "Minion signalled update request")
                    if(rq.size() == 1) {
                        println "Server received update request"
                        rqFound = true;
                    }
                }

                if(rqFound) {
                    def search = "Started Version " + project.version.replaceAll('SNAPSHOT', rootProject.buildDate)
                    def match = (check =~ search)
                    if(match.find()) {
                        println "Server successfully restarted after update"
                        ok = true;
                        break;
                    }
                }
                sleep(1000);
            }

            if(!ok) {
                throw new RuntimeException("Upgrade to current version failed");
            }
        }
    }

    releaseTest.dependsOn "binWaitForMigrateToCurrent_${key}"

    // dependencies are defined by the tasks. This does not guarantee an execution order. we need to manually define it
    // to be able to run multiple upgrade tests after each other.
    tasks["binStartTestBDeploy_${key}"].mustRunAfter("binInitTestBDeploy_${key}")
    tasks["binAddTestBDeployUser_${key}"].mustRunAfter("binStartTestBDeploy_${key}")
    tasks["binCheckTestBDeploy_${key}"].mustRunAfter("binAddTestBDeployUser_${key}")
    tasks["binCreateInstanceGroup_${key}"].mustRunAfter("binCheckTestBDeploy_${key}")
    tasks["binDownloadProd1_${key}"].mustRunAfter("binCreateInstanceGroup_${key}")
    tasks["binDownloadProd2_${key}"].mustRunAfter("binCreateInstanceGroup_${key}")
    tasks["binUnzipProd1_${key}"].mustRunAfter("binDownloadProd1_${key}")
    tasks["binUnzipProd2_${key}"].mustRunAfter("binDownloadProd2_${key}")
    tasks["binImportProd1_${key}"].mustRunAfter("binUnzipProd1_${key}")
    tasks["binImportProd2_${key}"].mustRunAfter("binUnzipProd2_${key}")
    tasks["binImportTestData_${key}"].mustRunAfter("binImportProd2_${key}")
    tasks["binSetupDemoServer_${key}"].mustRunAfter("binImportProd2_${key}")
    tasks["binMigrateToCurrent_${key}"].mustRunAfter("binSetupDemoServer_${key}")
    tasks["binWaitForMigrateToCurrent_${key}"].mustRunAfter("binMigrateToCurrent_${key}")
    tasks["binWaitForMigrateToCurrent_${key}"].finalizedBy("binTriggerStopBDeploy_${key}")

    task "binRunDemoServer_${key}" (dependsOn: "binSetupDemoServer_${key}") {
        doLast() {
            // no println will work in doLast, it will appear only AFTER the question is answered.
            def userInput = services.get(org.gradle.api.internal.tasks.userinput.UserInputHandler)
            def answer = userInput.askQuestion("Enter any value (or press enter) to stop the server", "Stop");
        }
    }
}

getTestBinVersions().each { setupBinServerTasks(it) }

// coverage for the rest of the tasks
jacoco {
    applyTo initTestBDeploy
    applyTo startTestBDeploy
    applyTo addTestBDeployUser
    applyTo checkTestBDeploy
}

// now all tasks that depend on any of the generated tasks
task setupDemoServer() {
    dependsOn(
        checkTestBDeploy
    )

    doFirst() {
        println("----------------------------------------------------------------------------------------")
        println("Successfully started demo server. Point your browser to https://localhost:${testServerPort}.")
        println("User and password for the demo server are 'admin' and 'admin'.")
        println("----------------------------------------------------------------------------------------")
    }
}

task runDemoServer(dependsOn: setupDemoServer) {
    doLast() {
        // no println will work in doLast, it will appear only AFTER the question is answered.
        def userInput = services.get(org.gradle.api.internal.tasks.userinput.UserInputHandler)
        def answer = userInput.askQuestion("Enter any value (or press enter) to stop the server", "Stop");
    }
}

// and fix all the common meta-data for all BDeploy JavaExec's.
tasks.findAll { it instanceof JavaExec && !it.name.startsWith("product") }.each { setupBDeployJavaExec(it) }

