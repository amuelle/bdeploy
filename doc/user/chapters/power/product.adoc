=== Integration of a new product

This chapter is intended for those who want to integrate their own *Product* to be deployed with *BDeploy*. Therefore a couple of YAML files are required. These files describe your product and all its applications together with some additional meta-data. These artifacts are required:

<<_app_info_yaml, app-info.yaml>>:: YAML file to describe one single *Application*. It is required once for every client and server *Application* of the product. 
<<_product_info_yaml, product-info.yaml>>:: YAML file with meta-data for the whole product.
<<_product_version_yaml,product-version.yaml>>:: YAML file required for every *Product Version*.
<<_application_template_yaml,application-template.yaml>>:: optional YAML file(s) which can be used to define *Application Templates*
<<_instance_template_yaml,instance-template.yaml>>:: optional YAML file(s) which can be used to define *Instance Templates*

This chapter will walk you through these artifacs, what they are for and how to define them.

[NOTE]
On the BDeploy Releases page you will find some zipped sample products for each release, see https://github.com/bdeployteam/bdeploy/releases

==== app-info.yaml

The `app-info.yaml` file is one of the most important parts of *BDeploy*. It describes an *Application*, especially its start command. This *Application* may be _any_ application which contains an _executable_ (whatever kind, script, executable, etc.) and which allows 'installation' by copy to a directory. This is important, as *BDeploy* will 'install' an application by ultimately copying the application to an automatically determined internal directory and launch it from there.

[TIP]
An *Application* should not modify files in its own installation directory (although it _can_ do it). *BDeploy* tries to aggressively pool applications per version to reduce the footprint on the disc. If this does not work for your application, use the `pooling` configuration to specify different behaviour.

[WARNING]
`runtimeDependencies` of *Applications* are always considered `GLOBAL` poolable.

[WARNING]
Client applications are always considered for `GLOBAL` pooling by the client launcher.

Basically, `app-info.yaml` allows you to specify which executable to run, and which parameters could *potentially* be used to configure the *Application*. The `app-info.yaml` does not specify an actual configuration, but describes all possible parameters for an *Application*.

The `app-info.yaml` file should be placed in the root directory of the *Application* it describes.

[source,yaml]
----
name: "My Application" <1>
type: CLIENT <2>
pooling: GLOBAL <3>

supportedOperatingSystems: <4>
  - LINUX
  - WINDOWS

branding: <5>
  icon: "branding/my-icon.ico"
  splash:
    image: "branding/my-splash.bmp"
    textRect:
      x: 20
      y: 174
      width: 400
      height: 20
      foreground: "#000000"
    progressRect:
      x: 15
      y: 194
      width: 450
      height: 12
      foreground: "#333333"

processControl: <6>
  gracePeriod: 3000
  supportedStartTypes:
   - INSTANCE
  supportsKeepAlive: true
  noOfRetries: 5
  startupProbe: <7>
     endpoint: "Startup Endpoint"
  lifenessProbe: <8>
     endpoint: "Lifeness Endpoint"
     initialDelaySeconds: 5
     periodSeconds: 10

startCommand: <9>
  launcherPath: "{{WINDOWS:launch.bat}}{{LINUX:launch.sh}}"
  parameters:
    - uid: "my.param.1"
      name: "My numeric parameter"
      longDescription: "This is a numeric parameter"
      groupName: "My Parameters"
      parameter: "--number"
      defaultValue: "5" 
      type: NUMERIC
    - uid: "my.param.2"
      name: "My textual parameter"
      longDescription: "This is a textual parameter"
      groupName: "My Parameters"
      parameter: "--text"
      mandatory: true
      suggestedValues:
        - "Value 1"
        - "Value 2"
    - uid: "my.param.3"
      name: "My conditional parameter"
      longDescription: "This is only visible and configurable if my.param.2 has value 'Value 1'"
      parameter: "--conditional"
      mandatory: true
      condition: <10>
        parameter: "my.param.2"
        must: EQUAL
        value: "Value 1"

stopCommand: <11>
  ...

endpoints: <12>
  http:
    - id: "my-endpoint" <13>
      path: "path/to/the/endpoint"
      port: "{{V:port-param}}" <14>
      secure: false
    - id: "Startup Endpoint"
      type: PROBE_STARTUP <15>
      path: "startup/endpoint"
      port: "{{V:port-param}}"
      secure: false
    - id: "Lifeness Endpoint"
      type: PROBE_STARTUP <15>
      path: "lifeness/endpoint"
      port: "{{V:port-param}}"
      secure: false

runtimeDependencies: <16>
  - "adoptium/jre:1.8.0_202-b08"
----

<1> A human readable name of the *Application*. Will be displayed in the *Configure Application* pane, and is also used as _default_ name for any process _instantiated_ from this *Application*.
<2> The type of the application, may be `SERVER` or `CLIENT`. `SERVER` applications can be deployed to *Nodes* (including the *master*) and there be started as server processes. `CLIENT` applications in comparison cannot be deployed on a *Node*, but run on a client PC instead.
<3> The supported pooling type for server applications. Supported values are `GLOBAL`, `LOCAL` and `NONE`. `GLOBAL` means that the application is fully poolable and may be installed once (per application version) and used by multiple instance versions of multiple instances. `LOCAL` means that there is limited pooling support, and the application may only be re-used inside a single instance (by multiple instance versions of that instance, e.g. when changin only configuration). `NONE` means that there is no pooling support and the application will be installed fresh per instance version, even if just configuration values changed. This gives some control on how to deploy applications which write data into their installation directory at runtime - which should be avoided of course for better pool-ability. This setting is currently ignored by the client application launcher. Client applications are always globally pooled.
<4> List of supported operating systems. This list is solely used to verify during import of the *Product*, that the *Application* actually supports the operating system under which it is listed in the `product-version.yaml`.
<5> Only relevant for `CLIENT` applications: The `branding` attribute controls the appearance of `CLIENT` type *Applications* when downloaded by the user. It can be used to specify an `icon` (used to decorate desktop links created by the _client installer_), and a `splash` screen. For the `splash`, you can fine tune the exact location used to display progress text and a progress bar while the application is downloaded to the client PC by the <<_launcher_cli,Launcher CLI>>. Paths are interpreted relative to the root folder of the *Application*.
<6> Only relevant for `SERVER` applications: Process control parameters allow to fine tune how `SERVER` type *Applications* are started and kept alive by *BDeploy*. For details, see the list of <<_supported_processcontrol_attributes, processControl>> attributes.
<7> A _startup probe_ can specify an HTTP Endpoint of type `PROBE_STARTUP` which is queried by *BDeploy* if specified until the endpoint returns a status code >= 200 and < 400. Once this happens, the _startup probe_ is considered to be successful and the *Process* state advances from _starting_ to _running_. The exact response reported by the *Process* is available from the *Process* details panels *Process Probes* section.
<8> A _lifeness probe_ can specify an HTTP Endpoint of type `PROBE_ALIVE` along with an initial delay in seconds and an interval in which the probe is queried. *BDeploy* starts querying _lifeness probes_ only after the application entered _running_ state. This happens either automatically when the process is started (if no _startup probe_ is configured), or once the existing _startup probe_ succeeded. The _lifeness probe_ is queried every `periodSeconds` seconds, and the application is considered to be alive if the endpoint returns a status code >= 200 and < 400. If the probe fails, the *Process* status is updated to indicate the problem. The exact response reported by the *Process* is available from the *Process* details panels *Process Probes* section.
<9> The start command of the *Application*. Contains the path to the _executable_ to launch, as well as all known and supported parameters. For details, see the full list of <<_supported_parameters_attributes,parameter>> attributes. To apply e.g. instance-specific values, <<_variable_expansion,Variable Expansion>> is a powerful tool. It can be used for the `launcherPath` and each parameter's `defaultValue`. In the Web UI it can be used for the parameter values.
<10> A conditional parameter is a parameter with a condition on it. The condition always refers to another parameter on the same application. The parameter with the condition set will only be visible and configurable if the condition on the referenced parameter is met.
<11> The optional stop command can be specified to provide a mechanism for clean application shutdown once *BDeploy* tries to stop a process. This command may use <<_variable_expansion,Variable Expansion>> to access parameter values of the `startCommand` (e.g. configured 'stop port', etc.). It is *not* configurable through the Web UI though. All parameter values will have their (expanded) default values set when the command is run. If no `stopCommand` is specified, *BDeploy* will try to gracefully quit the process (i.e. `SIGTERM`). Both with and without `stopCommand`, *BDeploy* resorts to a `SIGKILL` after the `<<_supported_parameters_attributes,gracePeriod>>` has expired.
<12> Optional definition of provided endpoints. Currently only HTTP endpoints are supported. These endpoints can be configured on the application later, including additional information like authentication, certificates, etc. *BDeploy* can later on call these endpoints when instructed to do so by a third-party application.
<13> The ID of the endpoint can be used to call the endpoint remotely by tunneling through potentially multiple levels of *BDeploy* servers.
<14> <<Variable Expansion>> can be used on most of the endpoint properties.
<15> The type of the endpoint can be used to control how the endpoint is handled by *BDeploy*.
<16> Optional runtime dependencies. These dependencies are included in the *Product* when building it. Dependencies are fetched from *<<Software Repositories>>*. `launcherPath` and parameter `defaultValue` (and of course the final configuration values) can access paths within each of the dependencies by using the `{{M:adoptium/jre}}` <<Variable Expansion>>, e.g. `launcherPath: {{M:adoptium/jre}}/bin/java`. Note that the declared _dependency_ does not need to specify an operating system, but *must* specify a _version_. This will be resolved by *BDeploy* to either an exact match if available, or a operating system specific match, e.g. `adoptium/jre/linux:1.8.0_202-b08` on `LINUX`. When _referencing_ the dependency in a <<Variable Expansion>>, neither an operating system nor a version is required - in fact it must not be specified.

===== Supported `processControl` attributes

[NOTE]
`processControl` is not supported for `CLIENT` applications.

[%header,cols="25,75"]
|===
|Attribute
|Description

|`supportedStartTypes`
|Can be either `MANUAL` (*Application* must be started _explicitly_ through the Web UI or CLI), `MANUAL_CONFIRM` (*Application* must be started _explicitly_ through the Web UI and a confirmation has to be entered by the user), or `INSTANCE` (the *Application* can be started _automatically_ when the *Start Instance* command is issued, either manually or during server startup - implies `MANUAL`).

|`supportsKeepAlive`
|Whether this *Application* may be automatically restarted by *BDeploy* if it exits.

|`noOfRetries`
|The number of time *BDeploy* will retry starting the *Application* if it `supportsKeepAlive`. The counter is reset after the *Application* is running for a certain amount of time without exiting.

|`gracePeriod`
|How long to wait (in milliseconds) for the *Application* to stop after issuing the `stopCommand`. After this timeout expired, the process will be killed.

|`startupProbe`
|Specifies a probe which can indicate to *BDeploy* that the application has completed startup.

|`lifenessProbe`
|Specifies a probe which can indicate to *BDeploy* whether the application is _alive_. _Alive_ means whether the application is currently performing as it should. *BDeploy* does not take immediate action on its own if a lifeness probe fails. It will only report the failure to the user.

|===

===== Supported `parameters` attributes

[NOTE]
Parameters appear on the final command line in *exact* the order as they appear in the `app-info.yaml` file, regardless of how they are presented in the Web UI, or how they are grouped using the `groupName` attribute. This allows to build complex command lines with positional parameters through `app-info.yaml`.

[%header,cols="15,5,5,80"]
|===
|Attribute
|Default
|Mandatory
|Description

|`uid`
|
|yes
|A unique ID of the parameter within the whole product which will contain the *Application* described by this `app-info.yaml`.

|`name`
|
|yes
|A human readable name of the parameter used as label in the configuration UI.

|`longDescription`
|
|no
|An optional human readable description of the paramater, which is displayed in an info popover next to the parameter in the Web UI.

|`groupName`
|
|no
a|An optional group name. The configuration UI may use this information to group parameters with the same `groupName` together.

|`suggestedValues`
|
|no
|An optional list of suggested values for paremters of type `STRING` (the default). The Web UI will present this list when editing the parameter value.

[CAUTION]
Although parameters in the UI are grouped together (and thus might change order), the order in which parameters appear on the final command line is exactly the order in which they are defined in the `app-info.yaml` file.

|`parameter`
|
|yes
a|The actual parameter, e.g. `--parameter`, `-Dmy.system.prop`, etc.

[NOTE]
The value of the parameter is not part of this definition, nor is any potential value separator (e.g. `=`).

|`hasValue`
|`true`
|no
|Whether the parameter has a value or not. If the parameter has no value, it is treated as `BOOLEAN` type parameter (i.e. it is either there (`true`) or not (`false`)).

|`valueAsSeparateArg`
|`false`
|no
|Whether the value of the parameter must be placed as a separate argument on the command line. If not, the value (if `hasValue`) will be concatenated to the `parameter` using the `valueSeparator`.

|`valueSeparator`
|`=`
|no
|The character (sequence) to use to concatenate the `parameter` and the actually configured value of it together. Used if not `valueAsSeparateArg`.

|`defaultValue`
|
|no
|A default value for the parameter. The default value may contain variable references according to the <<_variable_expansion,Variable Expansion>> rules.

|`global`
|`false`
|no
|Whether this parameter is `global`. This means that inside a single *Instance*, every process requiring this parameter will receive the same value. The configuration UI will provide input fields for the parameter for every *Application* which requires the parameter, and propagate value changes to all other *Applications* requiring it.

|`mandatory`
|`false`
|no
|Whether the parameter is required. If the parameter is not required, it is by default not put on the command line and must be added manually through a dedicated dialog on the configuration page.

|`fixed`
|`false`
|no
a|Whether the parameter is fixed. This means that the parameter can *not* be changed by the user.

Consider a command line like this:

[source,bash]
----
/path/to/java/bin/java -Dmy.prop=value -jar application.jar
----

In this case you will want the user to be able to edit the value of `-Dmy.prop` parameter, but the user may *never* be able to edit the `-jar application.jar` part. A definition for this command line would look like this:

[source,yaml]
----
startCommand:
  launcherPath: "{{M:openjdk/jre:1.8.0_u202-b08}}/bin/java{{WINDOWS:w.exe}}"
  parameters:
    - uid: "my.prop"
      name: "My Property"
      parameter: "-Dmy.prop"
      mandatory: true
    - uid: "my.jar"
      name: "Application JAR"
      parameter: "-jar"
      defaultValue: "application.jar"
      valueAsSeparateArg: true
      mandatory: true
      fixed: true <1>
----

The fixed flag will cause the parameter to *always* use the defined default value and disable editing in the configuration UI.

|`type`
|`STRING`
|no
a|Type of parameter. This defines the type of input field used to edit the parameter. Available are `STRING`, `NUMERIC`, `BOOLEAN`, `PASSWORD`, `CLIENT_PORT`, `SERVER_PORT`

The `CLIENT_PORT` and `SERVER_PORT` types are treated like `NUMERIC` parameters throughout the whole application, with the exception of the dialogs that deal with ports specifically.

|`condition`
|
|no
a| A conditional parameter is a parameter with a condition on it. The condition always refers to another parameter on the same application. The parameter with the condition set will only be visible and configurable if the condition on the referenced parameter is met.

A condition expression (isolated) looks like this:

[source,yaml]
----
condition:
  parameter: "my.param.2"
  must: EQUAL
  value: "Value 1"
----

The condition block understands the following fields:

[%header,cols="20,80"]
!===
!Name
!Description

!`parameter`
!the referenced parameters UID.

!`must`
!The type of condition.

!`value`
!The value to match against if required by the condition type.

!===

The `must` field understands the following condition types:

[%header,cols="20,80"]
!===
!Name
!Description

!`EQUAL`
!The referenced parameters value must equal the given condition value.

!`CONTAIN`
!The referenced parameters value must contain the given condition value.

!`START_WITH`
!The referenced parameters value must start with the given condition value.

!`END_WITH`
!The referenced parameters value must end with the given condition value.

!`BE_EMPTY`
a!The referenced parameters value must be empty. In case of `BOOLEAN` parameters the value must be `false`.

[NOTE]
Leading and trailing whitespaces are ignored for this check.

!`BE_NON_EMPTY`
a!The referenced parameters value must be any non-empty value. In case of `BOOLEAN` parameters the value must be `true`.

[NOTE]
Leading and trailing whitespaces are ignored for this check.

!===

[WARNING]
Be aware that the condition on a parameter has a higher precedence than `mandatory`. A `mandatory` parameter whos condition is not met is still not configurable. As soon as the condition is met, it is automatically added to the configuration using its default value.

[TIP]
If possible, a parameter with a condition should be defined *after* the parameter referenced in the condition if the referenced parameter is mandatory. This will make a difference when an application configuration is initially created by drag & drop.

|===

===== Supported `endpoints.http` attributes

[NOTE]
Endpoints definitions are templates which can later on be configured by the user. The only values not editable by the user are `id` and `path`.

[%header,cols="15,85"]
|===
|Attribute
|Description

|`id`
| The unique ID of the endpoint. This ID can be used by an authorized third-pary application to instruct *BDeploy* to call this endpoint and return the result.

|`type`
| Currently `DEFAULT`, `PROBE_STARTUP` and `PROBE_ALIVE` are supported. Endpoints referenced by _startup_ or _lifeness probes_ in the `processControl` section of a server process need to have the according type. If not specified, the `DEFAULT` type is assumed.

|`path`
| The path of the endpoint on the target process. *BDeploy* uses this and other parameters (`port`) to construct an URI to the local server.

|`port`
| The port this endpoint is hosted on. <<Variable Expansion>> can be used, for instance to reference a parameter of the application (using `{{V:port-param}}` where `port-param` is the ID of a parameter on the `startCommand`).

|`secure`
| Whether HTTPS should be used when calling the endpoint

|`trustAll`
| Whether to trust any certificate when using HTTPS to call the endpoint. Otherwise a custom `trustStore` must be set if a self-signed certificate is used by the application.

|`trustStore`
| Path to a KeyStore in the `JKS` format, containing certificates to trust. <<Variable Expansion>> can be used.

|`trustStorePass`
| The passphrase used to load the `trustStore`. <<Variable Expansion>> can be used.

|`authType`
| The type of authentication used by *BDeploy* when calling the endpoint. Can be `NONE`, `BASIC` or `DIGEST`.

|`authUser`
| The username to use for `BASIC` or `DIGEST` `authType`. <<Variable Expansion>> can be used.

|`authPass`
| The password to use for `BASIC` or `DIGEST` `authType`. <<Variable Expansion>> can be used.

|===

==== product-info.yaml

[NOTE]
There is no actual requirement for the file to be named `product-info.yaml`. This is just the default, but you can specify another name on the command line or in build tool integrations.

The `product-info.yaml` file describes which *Applications* are part of the final *Product*, as well as some additional *Product* meta-data.

[source,yaml]
----
name: My Product <1>
product: com.example/product <2>
vendor: My Company <3>

applications:
  - my-app1 <4>
  - my-app2
  
configTemplates: my-config <5>
pluginFolder: my-plugins <6>
applicationTemplates:
  - 'my-templates/app-template.yaml' <7>
instanceTemplates:
  - 'my-templates/template.yaml' <8>
versionFile: my-versions.yaml <9>
----

<1> A human readable name of the *Product* for display purposes in the Web UI
<2> A unique ID of the *Product* which is used to base *Instances* of. This should not change, as changing the *Product* ID of an existing *Instance* is not supported.
<3> The vendor of the product. Displayed in the Web UI and used when installing client applications.
<4> The list of *Applications* which are part of the *Product*. These IDs can be anything, they just have to match the IDs used in the `product-version.yaml` referenced below.
<5> Optional: A relative path to a directory containing configuration file templates, which will be used as the default set of configuration files when creating an *Instance* from the resulting *Product*.
<6> Optioanl: A relative path to a directory containing one or more plugin JAR files. These plugins are loaded by the server on demand and provided for use when configuring applications which use this very product version.
<7> A reference to an application template YAML file which defines an <<_application_template_yaml,`application-template.yaml`>>.
<8> A reference to an instance template YAML file which defines an <<_instance_template_yaml,`instance-template.yaml`>>
<9> The `product-version.yaml` which associates the *Application* IDs (used above) with actual paths to *Applications* on the file system.

==== product-version.yaml

[NOTE]
There is no actual requirement for the file to be named `product-version.yaml` as it is referenced from the `product-info.yaml` by relative path anyway. This is just the default name.

The `product-version.yaml` file associates *Application* IDs used in the `product-info.yaml` with actual locations on the local disc. This is used to find an import each included *Application* when importing the *Product*.

The reason why this file is separate from the `product-info.yaml` is because its content (e.g. version) is specific to a single product *Build* . Therfore the `product-version.yaml` ideally is created during the build process of the product by the build system of your choice. This is different to the `app-info.yaml` files and the `product-info.yaml` file as they are written manually.

[source,yaml]
----
version: "2.1.0.201906141135" <1>
appInfo:
  my-app1: <2>
    WINDOWS: "build/windows/app-info.yaml" <3>
    LINUX: "build/linux/app-info.yaml"
  my-app2:
    WINDOWS: "scripts/app2/app-info.yaml" <4>
    LINUX: "scripts/app2/app-info.yaml"
----

<1> A unique *Tag* to identify the product version. There is no requirement for any version-like syntax here, it can be basically anything. It should just be unique per *Product Version*.
<2> The *Application* ID must match the one used in `product-info.yaml`.
<3> You may have different binaries for a single application depending on the target operating system. It is not required to provide every application for every operating system. You can just leave out operating systems you don't care about.
<4> You can also use the exact same *Application* directory and `app-info.yaml` to satisfy multiple operating system targets for one *Application*.

==== application-template.yaml

[NOTE]
There is no actual requirement for the file to be named `application-template.yaml` as it is referenced from the `product-info.yaml` by relative path anyway. Multiple *Application Template* YAML files can exist and be referenced by `product-info.yaml`.

This file defines a single *Application Template*. A <<_product_info_yaml,`product-info.yaml`>> can reference multiple templates, from which the user can choose.

[source,yaml]
----
id: server-with-sleep <1>
application: server-app
name: "Server With Sleep"
description: "Server application which sleeps before exiting"
preferredProcessControlGroup: "First Group" <2>

variables: <3>
  - uid: sleep-timeout
    name: "Sleep Timeout"
    description: "The amount of time the server application should sleep"
    defaultValue: 60
    suggestedValues:
    - '60'
    - '120'

processControl: <4>
  startType: MANUAL_CONFIRM
  keepAlive: false
  noOfRetries: 3
  gracePeriod: 30000
  attachStdin: true

startParameters: <5>
- uid: param.sleep
  value: "{{T:sleep-timeout}}"
----

<1> An *Application Template* must have an ID. This can be used to reference it from an *Instance Template*.
<2> The preferred process control group is used to determine which process control group to use when applying the application template. This is only used if a *Process Control Group* with this name exists in the instance configuration. *Process Control Groups* can be pre-configured in an <<_instance_template_yaml,`instance-template.yaml`>>.
<3> A template can define (and use) template variables which are mandatory input by the user when using the template. A template variable can be referenced in parameter value definitions using the `{{T:varname}}` syntax. If the parameter value is numeric, you can also use simple arithmetic operations on the template variable like `{{T:varname:+10}}` which will add 10 to the numeric value of the template variable.
<4> A template can define arbitrary process control parameters to further control the default process control settings.
<5> Start command parameters are referenced by their UID, defined in <<_app_info_yaml,`app-info.yaml`>>. If a value is given, this value is applied. If not, the default value is used. If a parameter is optional, it will be added to the configuration if it is referenced in the template, regardless of whether a value is given or not.

==== instance-template.yaml

[NOTE]
There is no actual requirement for the file to be named `instance-template.yaml` as it is referenced from the `product-info.yaml` by relative path anyway. Multiple *Instance Template* YAML files can exist and be referenced by `product-info.yaml`.

This file defines a single *Instance Template*. A <<_product_info_yaml,`product-info.yaml`>> can reference multiple templates, from which the user can choose.

[source,yaml]
----
name: Default Configuration <1>
description: "Creates an instance with the default server and client configuration"

variables: <2>
  - uid: sleep-timeout
    name: "Sleep Timeout"
    description: "The amount of time the server application should sleep"
    defaultValue: 60

processControlGroups: <3>
  - name: "First Group"
    startType: "PARALLEL"
    startWait: "WAIT"
    stopType: "SEQUENTIAL"

groups: <4>
- name: "Server Apps"
  description: "All server applications"

  applications:
  - application: server-app
    name: "Server No Sleep"
    description: "Server application which immediately exits"
  - template: server-with-sleep <5>
  - application: server-app <6>
    name: "Server With Sleep"
    description: "Server application which sleeps before exiting"
    processControl:
      startType: MANUAL_CONFIRM
    startParameters: <7>
    - uid: param.sleep
      value: "{{T:sleep-timeout}}"
- name: "Client Apps"
  type: CLIENT <8>
  description: "All client applications"
  
  applications:
  - application: client-app
    description: "A default client application."
----

<1> Each *Instance Template* has a name and a description, which are shown on the *Instance Template* Wizard.
<2> A template can define (and use) template variables which are mandatory input by the user when using the template. A template variable can be referenced in parameter value definitions using the `{{T:varname}}` syntax. If the parameter value is numeric, you can also use simple arithmetic operations on the template variable like `{{T:varname:+10}}` which will add 10 to the numeric value of the template variable.
<3> *Process Control Groups* can be pre-configured for an instance template. If an application template later on wishes to be put into a certain *Process Control Group*, the group is created based on the template provided in the instance template.
<4> A template defines one or more groups of applications to configure. Each group can be assigned to a physical node available on the target system. Groups can be skipped by not assigning them to a node, so they provide a mechanism to provide logical groups of processes (as result of configuring the applications) that belong together and might be optional. It is up to the user whether a group is mapped to a node, or not. Multiple groups can be mapped to the same phsysical node.
<5> *Instance Templates* can reference *Application Templates* by their `id`. The *Instance Templates* can further refine an *Application Template* by setting any of the valid application fields in addition to the template reference.
<6> A template group contains one or more applications to configure, which each can consist of process control configuration and parameter definitions for the start command of the resulting process - exactly the same fields are valid as for *Application Tempaltes* - except for the `id` which is not required.
<7> Start command parameters are referenced by their UID, defined in <<_app_info_yaml,`app-info.yaml`>>. If a value is given, this value is applied. If not, the default value is used. If a parameter is optional, it will be added to the configuration if it is referenced in the template, regardless of whether a value is given or not.
<8> A template group can have either type `SERVER` (default) or `CLIENT`. A group may only contain applications of a compatible type, i.e. only `SERVER` applications in `SERVER` type group. When applying the group to a node, applications will be instantiated to processes according to their supported OS and the nodes physical OS. If a `SERVER` application does not support the target nodes OS, it is ignored.

An instance template will be presented to the user when visiting an <<Instance Templates,Empty Instance>>.

=== Building a Product

Now that you have a well-defined *Product* with one or more *Applications*, you will want to build/package that *Product* to be usable with *BDeploy*.

==== Via ZIP File and Web UI

The well-defined *Product* directory including *Applications* can be zipped and imported directly from the web interface.

The following conditions must be fulfilled for a successful import:

* ZIP files must be self-contained, e.g. only relative paths are allowed and no leaving of the zipped structure via ".." paths.
* YAML files must follow standard naming (product-info.yaml).
* External dependencies must either be included in the ZIP or already be available in the *Instance Group*. *Software Repositories* are not (yet) supported.

==== Via CLI

Once you have a `product-info.yaml` with it's `product-version.yaml` and all the `app-info.yaml` files in their respective *Application* directories, you can use the CLI to import the product as a single piece.

* Use `bdeploy product` to import the product by specifying a local *BHive* and the `product-info.yaml` to import from.
* Use `bhive push` to push the resulting *Product Manifest* from the local *BHive* to an *Instance Group* on a remote *BDeploy* server.

==== Via Gradle

*BDeploy* provides a https://plugins.gradle.org/plugin/io.bdeploy.gradle.plugin[*Gradle* plugin]. This plugin can be used to build a product out of your application.

Given a sample Java application which has been created from the default gradle template using `gradle init`, these are the changes you need to build a *BDeploy* product for this single application. For this demo, the application is named `test`.

[NOTE]
Add the below code to your existing `build.gradle`

`build.gradle`
[source,groovy]
----
plugins {
  ...
  id 'io.bdeploy.gradle.plugin' version '3.1.1-1' <1>
}

version = "1.0.0-SNAPSHOT" <2>

ext { <3>
  buildDate = new Date().format('yyyyMMddHHmmss')
  buildVersion = project.version.replaceAll('SNAPSHOT', buildDate)
}

task buildProduct(type: io.bdeploy.gradle.BDeployProductTask, dependsOn: installDist) { <4>
  product {
    version = project.ext.buildVersion
    productInfo = file('bdeploy/product-info.yaml')

    applications {
      test {
        yaml = new File(installDist.destinationDir, 'app-info.yaml')
      }
    }

    labels.put('buildDate', project.ext.buildDate)
  }
}

task zipProduct(type: io.bdeploy.gradle.BDeployZipTask, dependsOn: buildProduct) { <5>
  of buildProduct
  output = new File(buildDir, "product-" + project.ext.buildVersion + ".zip");
}


task pushProduct(type: io.bdeploy.gradle.BDeployPushTask, dependsOn: buildProduct) { <6>
  of buildProduct

  target.servers {
    if(project.hasProperty('server')) {
      myServer { <7>
        uri = project.getProperty('server')
        token = project.getProperty('token')
        instanceGroup = project.getProperty('instanceGroup')
      }
    }
  }
}

...
----

<1> Applies the plugin *BDeploy* gradle plugin.
<2> Sets the project version. *Gradle* does not strictly require a version, and uses 'unspecified' as default. *BDeploy* requires _some_ sort of version, and setting it for the whole project is good practice.
<3> Calculate a build date, which will be substituted instead of the `SNAPSHOT` in the version. This is optional, you could just plain use the version set. The actual `buildVersion` used later when building the product is derived from the project version and the `buildDate`.
<4> This task will actually build the product with the configured version. The actual data about the product is loaded from `bdeploy/product-info.yaml`, which we will create in a second. Note that this task depends on `installDist`, which will unpack the binary distribution of the application in this project into a folder, so *BDeploy* can import the individual files. Depending on the type of application and the way it is built, there might be different ways to achieve this.
<5> If `buildProduct` built a product, this task will package it as a ZIP file. Note that a ZIP will always contain _all of_ the product, whereas `pushProduct` can push only required deltas which are not present on the target server.
<6> The `pushProduct` task can push required deltas to one or more configured target servers. When calling this task, you need to set according project properties, e.g. using `-Pserver=https://server:7701/api` or in `~/.gradle/gradle.properties`.
<7> Multiple target servers can be specified in the `target.servers` section. The plugin will push to each of them.

Next we need the required descriptors for the product and the application. For this sample, the information will be the bare minimum, please see `<<_app_info_yaml, app-info.yaml>>` and `<<_product_info_yaml, product-info.yaml>>` for all supported content.

Lets start off with the `<<_app_info_yaml, app-info.yaml>>`, which describes the `test` application. 

[NOTE]
This file *must* be part of the binary distribution of an application and reside in its root directory. To achieve this, the most simple way (using the gradle `application` plugin) is to put the file in the subdirectory `src/main/dist` in the project folder.

`src/main/dist/app-info.yaml`
[source,yaml]
----
name: Test Application

supportedOperatingSystems: <1>
  - LINUX
  - WINDOWS

startCommand:
  launcherPath: "{{M:SELF}}/bin/test{{WINDOWS:.bat}}" <2>
----

<1> By default, the *BDeploy* plugin will make this application available for *all* the supported platforms specified in `app-info.yaml`. If required (usually it is not) you can configure a _different_ set of Operating Systems to build for in the `test` application configuration in `build.gradle` by adding a set of operating system literals (e.g. 'WINDOWS', 'LINUX') to the `os` list of the application.
<2> This demo `app-info.yaml` only defines the path to the launcher, which for this demo project (named `test`) is `bin/test` on `LINUX`, and `bin/test.bat` on `WINDOWS`.

Finally, we need a `<<_product_info_yaml, product-info.yaml>>` describing the product itself. We'll put this file into a `bdeploy` subfolder. This is not required, it can reside anywhere in the project. You just need to adapt the path to it in the `build.gradle`.

[NOTE]
The reason why you want to put this file into a separate folder is because it allows to reference various other files by relative path. Those files (and folders) must the reside next to the `<<_product_info_yaml, product-info.yaml>>`. Over time this can grow, and may clutter your source folders if you do not separate it.

`bdeploy/product-info.yaml`
[source,yaml]
----
name: Test Product
product: io.bdeploy/test <1>
vendor: BDeploy Team

applications:
  - test <2>

versionFile: product-version.yaml <3>
----

<1> This is the unique ID of the product. This is basically a 'primary key' and should not change over time.
<2> The `<<_product_info_yaml, product-info.yaml>>` needs to list included applications. These applications also need to be available from the `product-version.yaml`.
<3> The `versionFile` parameter *must* be set. If the relative path given here does *not* exist, the *BDeploy* *Gradle* plugin will generate this file for you, using the given version and applications. Otherwise you can provide this file and have more manual control over applications. In case the plugin generates the file for you, it will be deleted right after the build.

That's all that is required to build a product. You can now run `./gradlew zipProduct` on the CLI to try it out. The result will be a `build/product-1.0.0-XXX.zip` where `XXX` is the `buildDate` we set previously. The content of the ZIP file is a *BHive*, which is the internal data format used by *BDeploy*. You can upload this product to any *BDeploy* server using its Web UI.

[NOTE]
The `build` folder also contains the *BHive* in unzipped form in the `build/productBHive` folder. This folder is temporary but will hold all product versions built since the last `./gradlew clean`. You can use this *BHive* for manual pushing.

[NOTE]
The `pushProduct` task will do the same thing (build the product) but then push it to a target server. For this, you need to specify the `server`, `token` and `instanceGroup` project properties to match your setup. You can get a token by using the `Create Token...` action on the user menu in *BDeploy*. Make sure to create a _full token pack_ for this tool to work.

[WARNING]
Using `./gradlew clean buildProduct` you can build the *same* product version over and over again. However once pushed to a remote server, the same product version *must not* be reused. If you try to build and push the *same* version more than once, the server will silently ignore your attempt to push, as it assumes that it already has all the content (it has a product with this version already, and all artifacts are assumed to be immutable in *BDeploy*).

==== Via Eclipse TEA

*BDeploy* provides integration into https://www.eclipse.org/tea/[Eclipse TEA]. Using this integration, you can easily export *Eclipse RCP* based products as *Applications* and bundle them into a custom *Product*.

Once you have required files, select menu:TEA[TEA Build Library > Build BDeploy Product...]. You will be prompted which *Product* to build and where to put the resulting product. You can choose to create a self-contained ZIP, or to push deltas to a selected server.

image::images/TEA_build_product.png[TEA Integration Product Build,align=center,width=480,link="images/TEA_build_product.png"]

You can configure multiple servers by using the btn:[Add], btn:[Delete] and btn:[Edit] buttons.

image::images/TEA_edit_server.png[TEA BDeploy Server configuration,align=center,width=480,link="images/TEA_edit_server.png"]

Enter a description and a URL. You will then be able to use the btn:[Login] button to create a token for the server.

image::images/TEA_login.png[TEA BDeploy Login,align=center,width=480,link="images/TEA_login.png"]

Now you can use the btn:[Load Groups] to fetch a list of existing instance groups from the server to choose from. Finally, use the verity button to check whether the entered information is correct.

When confirming the build dialog, on first run you will be prompted to login to the Software Repositories *BDeploy* server configured in the TEA *BDeploy* preferences.

Since product builds are stored in the workspace, you can choose to re-push a previous build of the product (to the same or another server). Select menu:TEA[TEA Build Library > Push BDeploy Product...] to do so. You will be presented a list of available local product versions and the configured *BDeploy* servers.

image::images/TEA_push_product.png[TEA Integration Product Push,align=center,width=480,link="images/TEA_push_product.png"]

===== `products.yaml`

[NOTE]
There is no actual requirement for the file to be named `products.yaml`. This is just the default, but you can specify another name in the Eclipse TEA preferences.

This file is required and lists the `<<_product_build_yaml,product-build.yaml>>` files which are available to the integration.

[source,yaml]
----
products:
  "Product One": "prod-1-build.yaml"
  "Product Two": "prod-2-build.yaml"
----

The path to the `products.yaml` has to be configured in the *Eclipse TEA* preferences

image::images/TEA_preferences_products.png[TEA Integration Products Preference,align=center,width=480,link="images/TEA_preferences_products.png"]

The preferences also allow to configure a *BDeploy* server whos <<Software Repositories>> are used during resolution of <<Runtime Dependencies>>. You will be asked to log into this server once when starting a product build.

===== `product-build.yaml`

This file references a `<<_product_info_yaml,product-info.yaml>>` file and describes how to build the actual applications referenced in the `product-info.yaml`.

[source,yaml]
----
productInfoYaml: my-prod-info.yaml

applications:
  - name: my-app1
    type: RCP_PRODUCT
    includeOs: [WINDOWS, LINUX]
    application:
      product: App1ProdBuild
        
  - name: my-app2
    type: RCP_PRODUCT
    includeOs: [WINDOWS, LINUX]
    application:
      product: App2ProdBuild
----

The value for `applications.application.product` is *Eclipse TEA* specific and references the *Eclipse TEA* product _alias_ property.
