=== Integration of a new product

This chapter is intended for those who want to integrate their own *Product* to be deployed with *BDeploy*. Therefore a couple of YAML files are required. These files describe your product and all its applications together with some additional meta-data. These artifacts are required:

<<_app_info_yaml, app-info.yaml>>:: YAML file to describe one single *Application*. It is required once for every client and server *Application* of the product. 
<<_product_info_yaml, product-info.yaml>>:: YAML file with meta-data for the whole product.
<<_product_version_yaml,product-version.yaml>>:: YAML file required for every *Product Version*.
<<_instance_template_yaml,instance-template.yaml>>:: optional YAML file which can be used to define *Instance Templates*

This chapter will walk you through these artifacs, what they are for and how to define them.

[NOTE]
On the BDeploy Releases page you will find some zipped sample products for each release, see https://github.com/bdeployteam/bdeploy/releases

==== app-info.yaml

The `app-info.yaml` file is one of the most important parts of *BDeploy*. It describes an *Application*, especially its start command. This *Application* may be _any_ application which contains an _executable_ (whatever kind, script, executable, etc.) and which allows 'installation' by copy to a directory. This is important, as *BDeploy* will 'install' an application by ultimately copying the application to an automatically determined internal directory and launch it from there.

Basically, `app-info.yaml` allows you to specify which executable to run, and which parameters could *potentially* be used to configure the *Application*. The `app-info.yaml` does not specify an actual configuration, but describes all possible parameters for an *Application*.

The `app-info.yaml` file should be placed in the root directory of the *Application* it describes.

[source,yaml]
----
name: "My Application" <1>
type: CLIENT <2>

supportedOperatingSystems: <3>
  - LINUX
  - WINDOWS

branding: <4>
  icon: "branding/my-icon.ico"
  splash:
    image: "branding/my-splash.bmp"
    textRect:
      x: 20
      y: 174
      width: 400
      height: 20
      foreground: "#000000"
    progressRect:
      x: 15
      y: 194
      width: 450
      height: 12
      foreground: "#333333"

processControl: <5>
  gracePeriod: 3000
  supportedStartTypes:
   - INSTANCE
  supportsKeepAlive: true
  noOfRetries: 5

startCommand: <6>
  launcherPath: "{{WINDOWS:launch.bat}}{{LINUX:launch.sh}}"
  parameters:
    - uid: "my.param.1"
      name: "My numeric parameter"
      longDescription: "This is a numeric parameter"
      groupName: "My Parameters"
      parameter: "--number"
      defaultValue: "5" 
      type: NUMERIC
    - uid: "my.param.2"
      name: "My textual parameter"
      longDescription: "This is a textual parameter"
      groupName: "My Parameters"
      parameter: "--text"
      mandatory: true
      suggestedValues:
        - "Value 1"
        - "Value 2"

stopCommand: <7>
  ...

endpoints: <8>
  http:
    - id: "my-endpoint" <9>
      path: "path/to/the/endpoint"
      port: "{{V:port-param}}" <10>
      secure: false

runtimeDependencies: <11>
  - "adoptopenjdk/jre:1.8.0_202-b08"
----

<1> A human readable name of the *Application*. Will be displayed in the *Configure Application* pane, and is also used as _default_ name for any process _instantiated_ from this *Application*.
<2> The type of the application, may be `SERVER` or `CLIENT`. `SERVER` applications can be deployed to master or slave *Nodes* and there be started as server processes. `CLIENT` applications in comparison cannot be deployed on a *Node*, but run on a client PC instead.
<3> List of supported operating systems. This list is solely used to verify during import of the *Product*, that the *Application* actually supports the operating system under which it is listed in the `product-version.yaml`.
<4> Only relevant for `CLIENT` applications: The `branding` attribute controls the appearance of `CLIENT` type *Applications* when downloaded by the user. It can be used to specify an `icon` (used to decorate desktop links created by the _client installer_), and a `splash` screen. For the `splash`, you can fine tune the exact location used to display progress text and a progress bar while the application is downloaded to the client PC by the <<_launcher_cli,Launcher CLI>>. Paths are interpreted relative to the root folder of the *Application*.
<5> Only relevant for `SERVER` applications: Process control parameters allow to fine tune how `SERVER` type *Applications* are started and kept alive by *BDeploy*. For details, see the list of <<_supported_processcontrol_attributes, processControl>> attributes.
<6> The start command of the *Application*. Contains the path to the _executable_ to launch, as well as all known and supported parameters. For details, see the full list of <<_supported_parameters_attributes,parameter>> attributes. To apply e.g. instance-specific values, <<_variable_expansion,Variable Expansion>> is a powerful tool. It can be used for the `launcherPath` and each parameter's `defaultValue`. In the Web UI it can be used for the parameter values.
<7> The optional stop command can be specified to provide a mechanism for clean application shutdown once *BDeploy* tries to stop a process. This command may use <<_variable_expansion,Variable Expansion>> to access parameter values of the `startCommand` (e.g. configured 'stop port', etc.). It is *not* configurable through the Web UI though. All parameter values will have their (expanded) default values set when the command is run. If no `stopCommand` is specified, *BDeploy* will try to gracefully quit the process (i.e. `SIGTERM`). Both with and without `stopCommand`, *BDeploy* resorts to a `SIGKILL` after the `<<_supported_parameters_attributes,gracePeriod>>` has expired.
<8> Optional definition of provided endpoints. Currently only HTTP endpoints are supported. These endpoints can be configured on the application later, including additional information like authentication, certificates, etc. *BDeploy* can later on call these endpoints when instructed to do so by a third-party application.
<9> The ID of the endpoint can be used to call the endpoint remotely by tunneling through potentially multiple levels of *BDeploy* servers.
<10> <<Variable Expansion>> can be used on most of the endpoint properties.
<11> Optional runtime dependencies. These dependencies are included in the *Product* when building it. Dependencies are fetched from *<<Software Repositories>>*. `launcherPath` and parameter `defaultValue` (and of course the final configuration values) can access paths within each of the dependencies by using the `{{M:adoptopenjdk/jre:1.8.0_202-b08}}` <<Variable Expansion>>, e.g. `launcherPath: {{M:adoptopenjdk/jre:1.8.0_202-b08}}/bin/java`. Also note that the declared dependency does not specify an operating system. This will be resolved by *BDeploy* to either an exact match, e.g. `adoptopenjdk/jre/linux:1.8.0_202-b08` on `LINUX`.

===== Supported `processControl` attributes

[%header,cols="25,75"]
|===
|Attribute
|Description

|`supportedStartTypes`
|Can be either `MANUAL` (*Application* must be started _explicitly_ through the Web UI or CLI), `MANUAL_CONFIRM` (*Application* must be started _explicitly_ through the Web UI and a confirmation has to be entered by the user), or `INSTANCE` (the *Application* can be started _automatically_ when the *Start Instance* command is issued, either manually or during server startup - implies `MANUAL`).

|`supportsKeepAlive`
|Whether this *Application* may be automatically restarted by *BDeploy* if it exits.

|`noOfRetries`
|The number of time *BDeploy* will retry starting the *Application* if it `supportsKeepAlive`. The counter is reset after the *Application* is running for a certain amount of time without exiting.

|`gracePeriod`
|How long to wait (in milliseconds) for the *Application* to stop after issuing the `stopCommand`. After this timeout expired, the process will be killed.

|===

===== Supported `parameters` attributes

[NOTE]
Parameters appear on the final command line in *exact* the order as they appear in the `app-info.yaml` file, regardless of how they are presented in the Web UI, or how they are grouped using the `groupName` attribute. This allows to build complex command lines with positional parameters through `app-info.yaml`.

[%header,cols="15,5,5,80"]
|===
|Attribute
|Default
|Mandatory
|Description

|`uid`
|
|yes
|A unique ID of the parameter within the whole product which will contain the *Application* described by this `app-info.yaml`.

|`name`
|
|yes
|A human readable name of the parameter used as label in the configuration UI.

|`longDescription`
|
|no
|An optional human readable description of the paramater, which is displayed in an info popover next to the parameter in the Web UI.

|`groupName`
|
|no
a|An optional group name. The configuration UI may use this information to group parameters with the same `groupName` together.

|`suggestedValues`
|
|no
|An optional list of suggested values for paremters of type `STRING` (the default). The Web UI will present this list when editing the parameter value.

[CAUTION]
Although parameters in the UI are grouped together (and thus might change order), the order in which parameters appear on the final command line is exactly the order in which they are defined in the `app-info.yaml` file.

|`parameter`
|
|yes
a|The actual parameter, e.g. `--parameter`, `-Dmy.system.prop`, etc.

[NOTE]
The value of the parameter is not part of this definition, nor is any potential value separator (e.g. `=`).

|`hasValue`
|`true`
|no
|Whether the parameter has a value or not. If the parameter has no value, it is treated as `BOOLEAN` type parameter (i.e. it is either there (`true`) or not (`false`)).

|`valueAsSeparateArg`
|`false`
|no
|Whether the value of the parameter must be placed as a separate argument on the command line. If not, the value (if `hasValue`) will be concatenated to the `parameter` using the `valueSeparator`.

|`valueSeparator`
|`=`
|no
|The character (sequence) to use to concatenate the `parameter` and the actually configured value of it together. Used if not `valueAsSeparateArg`.

|`defaultValue`
|
|no
|A default value for the parameter. The default value may contain variable references according to the <<_variable_expansion,Variable Expansion>> rules.

|`global`
|`false`
|no
|Whether this parameter is `global`. This means that inside a single *Instance*, every process requiring this parameter will receive the same value. The configuration UI will provide input fields for the parameter for every *Application* which requires the parameter, and propagate value changes to all other *Applications* requiring it.

|`mandatory`
|`false`
|no
|Whether the parameter is required. If the parameter is not required, it is by default not put on the command line and must be added manually through a dedicated dialog on the configuration page.

|`fixed`
|`false`
|no
a|Whether the parameter is fixed. This means that the parameter can *not* be changed by the user.

Consider a command line like this:

[source,bash]
----
/path/to/java/bin/java -Dmy.prop=value -jar application.jar
----

In this case you will want the user to be able to edit the value of `-Dmy.prop` parameter, but the user may *never* be able to edit the `-jar application.jar` part. A definition for this command line would look like this:

[source,yaml]
----
startCommand:
  launcherPath: "{{M:openjdk/jre:1.8.0_u202-b08}}/bin/java{{WINDOWS:w.exe}}"
  parameters:
    - uid: "my.prop"
      name: "My Property"
      parameter: "-Dmy.prop"
      mandatory: true
    - uid: "my.jar"
      name: "Application JAR"
      parameter: "-jar"
      defaultValue: "application.jar"
      valueAsSeparateArg: true
      mandatory: true
      fixed: true <1>
----

The fixed flag will cause the parameter to *always* use the defined default value and disable editing in the configuration UI.

|`type`
|`STRING`
|no
|Type of parameter. This defines the type of input field used to edit the parameter. Available are `STRING`, `NUMERIC`, `BOOLEAN`, `PASSWORD`.

|===

===== Supported `endpoints.http` attributes

[NOTE]
Endpoints definitions are templates which can later on be configured by the user. The only values not editable by the user are `id` and `path`.

[%header,cols="15,80"]
|===
|Attribute
|Description

|`id`
| The unique ID of the endpoint. This ID can be used by an authorized third-pary application to instruct *BDeploy* to call this endpoint and return the result.

|`path`
| The path of the endpoint on the target process. *BDeploy* uses this and other parameters (`port`) to construct an URI to the local server.

|`port`
| The port this endpoint is hosted on. <<Variable Expansion>> can be used, for instance to reference a parameter of the application (using `{{V:port-param}}` where `port-param` is the ID of a parameter on the `startCommand`).

|`secure`
| Whether HTTPS should be used when calling the endpoint

|`trustAll`
| Whether to trust any certificate when using HTTPS to call the endpoint. Otherwise a custom `trustStore` must be set if a self-signed certificate is used by the application.

|`trustStore`
| Path to a KeyStore in the `JKS` format, containing certificates to trust. <<Variable Expansion>> can be used.

|`trustStorePass`
| The passphrase used to load the `trustStore`. <<Variable Expansion>> can be used.

|`authType`
| The type of authentication used by *BDeploy* when calling the endpoint. Can be `NONE`, `BASIC` or `DIGEST`.

|`authUser`
| The username to use for `BASIC` or `DIGEST` `authType`. <<Variable Expansion>> can be used.

|`authPass`
| The password to use for `BASIC` or `DIGEST` `authType`. <<Variable Expansion>> can be used.

|===

==== product-info.yaml

[NOTE]
There is no actual requirement for the file to be named `product-info.yaml`. This is just the default, but you can specify another name on the command line or in build tool integrations.

The `product-info.yaml` file describes which *Applications* are part of the final *Product*, as well as some additional *Product* meta-data.

[source,yaml]
----
name: My Product <1>
product: com.example/product <2>
vendor: My Company <3>

applications:
  - my-app1 <4>
  - my-app2
  
configTemplates: my-config <5>
pluginFolder: my-plugins <6>
templates:
  - 'my-templates/template.yaml' <7>
versionFile: my-versions.yaml <8>
----

<1> A human readable name of the *Product* for display purposes in the Web UI
<2> A unique ID of the *Product* which is used to base *Instances* of. This should not change, as changing the *Product* ID of an existing *Instance* is not supported.
<3> The vendor of the product. Displayed in the Web UI and used when installing client applications.
<4> The list of *Applications* which are part of the *Product*. These IDs can be anything, they just have to match the IDs used in the `product-version.yaml` referenced below.
<5> Optional: A relative path to a directory containing configuration file templates, which will be used as the default set of configuration files when creating an *Instance* from the resulting *Product*.
<6> Optioanl: A relative path to a directory containing one or more plugin JAR files. These plugins are loaded by the server on demand and provided for use when configuring applications which use this very product version.
<7> A reference to a template YAML file which defines an <<_instance_template_yaml,`instance-template.yaml`>>
<8> The `product-version.yaml` which associates the *Application* IDs (used above) with actual paths to *Applications* on the file system.

==== product-version.yaml

[NOTE]
There is no actual requirement for the file to be named `product-version.yaml` as it is referenced from the `product-info.yaml` by relative path anyway. This is just the default name.

The `product-version.yaml` file associates *Application* IDs used in the `product-info.yaml` with actual locations on the local disc. This is used to find an import each included *Application* when importing the *Product*.

The reason why this file is separate from the `product-info.yaml` is because its content (e.g. version) is specific to a single product *Build* . Therfore the `product-version.yaml` ideally is created during the build process of the product by the build system of your choice. This is different to the `app-info.yaml` files and the `product-info.yaml` file as they are written manually.

[source,yaml]
----
version: "2.1.0.201906141135" <1>
appInfo:
  my-app1: <2>
    WINDOWS: "build/windows/app-info.yaml" <3>
    LINUX: "build/linux/app-info.yaml"
  my-app2:
    WINDOWS: "scripts/app2/app-info.yaml" <4>
    LINUX: "scripts/app2/app-info.yaml"
----

<1> A unique *Tag* to identify the product version. There is no requirement for any version-like syntax here, it can be basically anything. It should just be unique per *Product Version*.
<2> The *Application* ID must match the one used in `product-info.yaml`.
<3> You may have different binaries for a single application depending on the target operating system. It is not required to provide every application for every operating system. You can just leave out operating systems you don't care about.
<4> You can also use the exact same *Application* directory and `app-info.yaml` to satisfy multiple operating system targets for one *Application*.

==== instance-template.yaml

[NOTE]
There is no actual requirement for the file to be named `instance-template.yaml` as it is referenced from the `product-info.yaml` by relative path anyway. Multiple *Instance Template* YAML files can exist and be referenced by `product-info.yaml`.

This file defines a single *Instance Template*. A <<_product_info_yaml,`product-info.yaml`>> can reference multiple templates, from which the user can choose.

[source,yaml]
----
name: Default Configuration <1>
description: "Creates an instance with the default server and client configuration"

variables: <2>
  - uid: sleep-timeout
    name: "Sleep Timeout"
    description: "The amount of time the server application should sleep"
    defaultValue: 60

groups: <3>
- name: "Server Apps"
  description: "All server applications"

  applications:
  - application: server-app
    name: "Server No Sleep"
    description: "Server application which immediately exits"
  - application: server-app <4>
    name: "Server With Sleep"
    description: "Server application which sleeps before exiting"
    processControl:
      startType: MANUAL_CONFIRM
    startParameters: <5>
    - uid: param.sleep
      value: "{{T:sleep-timeout}}"
- name: "Client Apps"
  type: CLIENT <6>
  description: "All client applications"
  
  applications:
  - application: client-app
    description: "A default client application."
----

<1> Each *Instance Template* has a name and a description, which are shown on the *Instance Template* Wizard.
<2> A template can define (and use, see further down in the example) variables which are mandatory input by the user when using the template.
<3> A template defines one or more groups. Each group can be assigned to a physical node available on the target system. Groups can be skipped by not assigning them to a node, so they provide a mechanism to provide logical groups of processes that belong together and might be optional. It is up to the user whether a group is mapped to a node, or not. Multiple groups can be mapped to the same phsysical node.
<4> A template group contains one or more application configurations, which can consist of process control configuration and parameter definitions for the start command of that application.
<5> Start command parameters are referenced by their UID, defined in <<_app_info_yaml,`app-info.yaml`>>. If a value is given, this value is applied. If not, the default value is used. If a parameter is optional, it will be added to the configuration if it is referenced in the template, regardless of whether a value is given or not.
<6> A template group can have either type `SERVER` (default) or `CLIENT`. A group may only contain applications of a compatible type, i.e. only `SERVER` applications in `SERVER` type group.

An instance template will be presented to the user when visiting an <<Instance Templates,Empty Instance>>.

=== Building a Product

Now that you have a well-defined *Product* with one or more *Applications*, you will want to build/package that *Product* to be usable with *BDeploy*.

==== Via ZIP File and Web UI

The well-defined *Product* directory including *Applications* can be zipped and imported directly from the web interface.

The following conditions must be fulfilled for a successful import:

* ZIP files must be self-contained, e.g. only relative paths are allowed and no leaving of the zipped structure via ".." paths.
* YAML files must follow standard naming (product-info.yaml).
* External dependencies must either be included in the ZIP or already be available in the *Instance Group*. *Software Repositories* are not (yet) supported.

==== Via CLI

Once you have a `product-info.yaml` with it's `product-version.yaml` and all the `app-info.yaml` files in their respective *Application* directories, you can use the CLI to import the product as a single piece.

* Use `bdeploy product` to import the product by specifying a local *BHive* and the `product-info.yaml` to import from.
* Use `bhive push` to push the resulting *Product Manifest* from the local *BHive* to an *Instance Group* on a remote *BDeploy* server.

==== Via Eclipse TEA

*BDeploy* provides integration into https://www.eclipse.org/tea/[Eclipse TEA]. Using this integration, you can easily export *Eclipse RCP* based products as *Applications* and bundle them into a custom *Product*.

Once you have required files, select menu:TEA[TEA Build Library > Build BDeploy Product...]. You will be prompted which *Product* to build and where to put the resulting product. You can choose to create a self-contained ZIP, or to push deltas to a selected server.

image::images/TEA_build_product.png[TEA Integration Product Build,align=center,width=480,link="images/TEA_build_product.png"]

You can configure multiple servers by using the btn:[Add], btn:[Delete] and btn:[Edit] buttons.

image::images/TEA_edit_server.png[TEA BDeploy Server configuration,align=center,width=480,link="images/TEA_edit_server.png"]

Enter a description and a URL. You will then be able to use the btn:[Login] button to create a token for the server.

image::images/TEA_login.png[TEA BDeploy Login,align=center,width=480,link="images/TEA_login.png"]

Now you can use the btn:[Load Groups] to fetch a list of existing instance groups from the server to choose from. Finally, use the verity button to check whether the entered information is correct.

When confirming the build dialog, on first run you will be prompted to login to the Software Repositories *BDeploy* server configured in the TEA *BDeploy* preferences.

Since product builds are stored in the workspace, you can choose to re-push a previous build of the product (to the same or another server). Select menu:TEA[TEA Build Library > Push BDeploy Product...] to do so. You will be presented a list of available local product versions and the configured *BDeploy* servers.

image::images/TEA_push_product.png[TEA Integration Product Push,align=center,width=480,link="images/TEA_push_product.png"]

===== `products.yaml`

[NOTE]
There is no actual requirement for the file to be named `products.yaml`. This is just the default, but you can specify another name in the Eclipse TEA preferences.

This file is required and lists the `<<_product_build_yaml,product-build.yaml>>` files which are available to the integration.

[source,yaml]
----
products:
  "Product One": "prod-1-build.yaml"
  "Product Two": "prod-2-build.yaml"
----

The path to the `products.yaml` has to be configured in the *Eclipse TEA* preferences

image::images/TEA_preferences_products.png[TEA Integration Products Preference,align=center,width=480,link="images/TEA_preferences_products.png"]

The preferences also allow to configure a *BDeploy* server whos <<Software Repositories>> are used during resolution of <<Runtime Dependencies>>. You will be asked to log into this server once when starting a product build.

===== `product-build.yaml`

This file references a `<<_product_info_yaml,product-info.yaml>>` file and describes how to build the actual applications referenced in the `product-info.yaml`.

[source,yaml]
----
productInfoYaml: my-prod-info.yaml

applications:
  - name: my-app1
    type: RCP_PRODUCT
    includeOs: [WINDOWS, LINUX]
    application:
      product: App1ProdBuild
        
  - name: my-app2
    type: RCP_PRODUCT
    includeOs: [WINDOWS, LINUX]
    application:
      product: App2ProdBuild
----

The value for `applications.application.product` is *Eclipse TEA* specific and references the *Eclipse TEA* product _alias_ property.
