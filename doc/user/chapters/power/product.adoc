=== Defining your own Product

To define your own *Product* which can be deployed with *BDeploy*, you will need to provide some information to *BDeploy* about the actual applications and some additional meta-data. This chapter will walk you through the required artifacts and how to define them.

==== app-info.yaml

The `app-info.yaml` file is one of the most important parts of *BDeploy*. It describes an *Application*. This *Application* may be _any_ application which contains an _executable_ (whatever kind, script, executable, etc.) and which allows 'installation' by copy to a directory. This is important, as *BDeploy* will 'install' an application by ultimately copying the application to an automatically determined internal directory and launch it from there.

Basically, `app-info.yaml` allows you to specify which executable to run, and which parameters could *potentially* be used to configure the *Application*. The `app-info.yaml` does not specify an actual configuration, but describes all possible parameters for an *Application*.

The `app-info.yaml` file should be placed in the root directory of the *Application* it describes.

[source,yaml]
----
name: "My Application" <1>
type: CLIENT <2>

supportedOperatingSystems: <3>
  - LINUX
  - WINDOWS

branding: <4>
  icon: "branding/my-icon.ico"
  splash:
    image: "branding/my-splash.bmp"
    textRect:
      x: 20
      y: 174
      width: 400
      height: 20
      foreground: "#000000"
    progressRect:
      x: 15
      y: 194
      width: 450
      height: 12
      foreground: "#333333"

processControl: <5>
  gracePeriod: 3000
  supportedStartTypes:
   - INSTANCE
  supportsKeepAlive: true
  noOfRetries: 5

startCommand: <6>
  launcherPath: "{{WINDOWS:launch.bat}}{{LINUX:launch.sh}}"
  parameters:
    - uid: "my.param.1"
      name: "My numeric parameter"
      longDescription: "This is a numeric parameter"
      groupName: "My Parameters"
      parameter: "--number"
      defaultValue: "5" 
      type: NUMERIC
    - uid: "my.param.2"
      name: "My textual parameter"
      longDescription: "This is a textual parameter"
      groupName: "My Parameters"
      parameter: "--text"
      mandatory: true

stopCommand: <7>
  ...

runtimeDependencies: <8>
  - "adoptopenjdk/jre:1.8.0_202-b08"
----

<1> A human readable name of the *Application*. Will be displayed in the *Configure Application* pane, and is also used as _default_ name for any process _instantiated_ from this *Application*.
<2> The type of the application, may be `SERVER` or `CLIENT`. `CLIENT` applications cannot be deployed on a *BDeploy* node, but are downloadable instead. `SERVER` applications cannot be downloaded by users, but are only deployable to *BDeploy* nodes.
<3> List of supported operating systems. This list is solely used to verify during import of the *Product*, that the *Application* actually supports the operating system under which it is listed in the `product-version.yaml`.
<4> The `branding` attribute controls the appearance of `CLIENT` type applications when downloaded by the user. It can be used to specify an `icon` (used to decorate desktop links created by the _client installer_), and a `splash` screen. For the `splash`, you can fine tune the exact location used to display progress text and a progress bar while the application is downloaded to the client PC by the <<_launcher_cli,Launcher CLI>>. Paths are interpreted relative to the root folder of the *Application*.
<5> Process control parameters allow to fine tune how `SERVER` type *Applications* are treated by *BDeploy*. For details, see <<_supported_processcontrol_attributes,Supported `processControl` Attributes>>.
<6> The start command of the *Application*. Contains the path to the _executable_ to launch, as well as all known and supported parameters. A single parameter is actually the most complex single object in *BDeploy*. For details, see <<_supported_parameters_attributes,Supported `parameters` Attributes>>. Both the `launcherPath` and each parameter's `defaultValue` can use <<_variable_expansion,Variable Expansion>> just the same as in the Web UI.
<7> The optional stop command can be specified to provide a mechanism for clean application shutdown once *BDeploy* tries to stop a process. This command may use <<_variable_expansion,Variable Expansion>> to access parameter values of the `startCommand` (e.g. configured 'stop port', etc.). It is *not* configurable through the Web UI though. All parameter values will have their (expanded) default values set when the command is run. If no `stopCommand` is specified, *BDeploy* will try to gracefully quit the process (i.e. `SIGTERM`). Both with and without `stopCommand`, *BDeploy* resorts to a `SIGKILL` after the `<<_supported_parameters_attributes,gracePeriod>>` has expired.
<8> Optional additional dependencies. These dependencies are included in the *Product* when building it. Dependencies are fetched from *<<_software_repositories,Software Repositories>>*. `launcherPath` and parameter `defaultValue` (and of course the final configuration values) can access paths within each of the dependencies by using the `{{M:adoptopenjdk/jre:1.8.0_202-b08}}` <<_variable_expansion,Variable Expansion>>, e.g. `launcherPath: {{M:adoptopenjdk/jre:1.8.0_202-b08}}/bin/java`. Also note that the declared dependency does not specify an operating system. This will be resolved by *BDeploy* to either an exact match, e.g. `adoptopenjdk/jre/linux:1.8.0_202-b08` on `LINUX`.

===== Supported `processControl` Attributes

[%header,cols="25,75"]
|===
|Attribute
|Description

|`supportedStartTypes`
|Can be either `MANUAL` (*Application* must be started _explicitly_ through the Web UI or CLI), `MANUAL_CONFIRM` (*Application* must be started _explicitly_ through the Web UI and a confirmation has to be entered by the user), or `INSTANCE` (the *Application* can be started _automatically_ when the *Start Instance* command is issued, either manually or during server startup - implies `MANUAL`).

|`supportsKeepAlive`
|Whether this *Application* may be automatically restarted by *BDeploy* if it exits.

|`noOfRetries`
|The number of time *BDeploy* will retry starting the *Application* if it `supportsKeepAlive`. The counter is reset after the *Application* is running for a certain amount of time without exiting.

|`gracePeriod`
|How long to wait (in milliseconds) for the *Application* to stop after issuing the `stopCommand`. After this timeout expired, the process will be killed.

|===

===== Supported `parameters` Attributes

[NOTE]
Parameters appear on the final command line in *exact* the order as they appear in the `app-info.yaml` file, regardless of how they are presented in the Web UI, or how they are grouped using the `groupName` attribute. This allows to build complex command lines with positional parameters through `app-info.yaml`.

[%header,cols="15,5,5,80"]
|===
|Attribute
|Default
|Mandatory
|Description

|`uid`
|
|yes
|A unique ID of the parameter within the whole product which will contain the *Application* described by this `app-info.yaml`.

|`name`
|
|yes
|A human readable name of the parameter used as label in the configuration UI.

|`longDescription`
|
|no
|An optional human readable description of the paramater, which is displayed in an info popover next to the parameter in the Web UI.

|`groupName`
|
|no
a|An optional group name. The configuration UI may use this information to group parameters with the same `groupName` together.

[CAUTION]
Although parameters in the UI are grouped together (and thus might change order), the order in which parameters appear on the final command line is exactly the order in which they are defined in the `app-info.yaml` file.

|`parameter`
|
|yes
a|The actual parameter, e.g. `--parameter`, `-Dmy.system.prop`, etc.

[NOTE]
The value of the parameter is not part of this definition, nor is any potential value separator (e.g. `=`).

|`hasValue`
|`true`
|no
|Whether the parameter has a value or not. If the parameter has no value, it is treated as `BOOLEAN` type parameter (i.e. it is either there (`true`) or not (`false`)).

|`valueAsSeparateArg`
|`false`
|no
|Whether the value of the parameter must be placed as a separate argument on the command line. If not, the value (if `hasValue`) will be concatenated to the `parameter` using the `valueSeparator`.

|`valueSeparator`
|`=`
|no
|The character (sequence) to use to concatenate the `parameter` and the actually configured value of it together. Used if not `valueAsSeparateArg`.

|`defaultValue`
|
|no
|A default value for the parameter. The default value may contain variable references according to the <<_variable_expansion,Variable Expansion>> rules.

|`global`
|`false`
|no
|Whether this parameter is `global`. This means that inside a single *Instance*, every process requiring this parameter will receive the same value. The configuration UI will provide input fields for the parameter for every *Application* which requires the parameter, and propagate value changes to all other *Applications* requiring it.

|`mandatory`
|`false`
|no
|Whether the parameter is required. If the parameter is not required, it is by default not put on the command line and must be added manually through a dedicated dialog on the configuration page.

|`fixed`
|`false`
|no
a|Whether the parameter is fixed. This means that the parameter can *not* be changed by the user.

Consider a command line like this:

[source,bash]
----
/path/to/java/bin/java -Dmy.prop=value -jar application.jar
----

In this case you will want the user to be able to edit the value of `-Dmy.prop` parameter, but the user may *never* be able to edit the `-jar application.jar` part. A definition for this command line would look like this:

[source,yaml]
----
startCommand:
  launcherPath: "{{M:openjdk/jre:1.8.0_u202-b08}}/bin/java{{WINDOWS:w.exe}}"
  parameters:
    - uid: "my.prop"
      name: "My Property"
      parameter: "-Dmy.prop"
      mandatory: true
    - uid: "my.jar"
      name: "Application JAR"
      parameter: "-jar"
      defaultValue: "application.jar"
      valueAsSeparateArg: true
      mandatory: true
      fixed: true <1>
----

<1> The fixed flag will cause the parameter to *always* use the defined default value and disable editing in the configuration UI.

|`type`
|`STRING`
|no
|Type of parameter. This defines the type of input field used to edit the parameter. Available are `STRING`, `NUMERIC`, `BOOLEAN`, `PASSWORD`.

|===

==== product-info.yaml

[NOTE]
There is no actual requirement for the file to be named `product-info.yaml`. This is just the default, but you can specify another name on the command line or in build tool integrations.

The `product-info.yaml` file describes which *Applications* are part of the final *Product*, as well as some basic *Product* properties.

[source,yaml]
----
name: My Product <1>
product: com.example/product <2>

applications:
  - my-app1 <3>
  - my-app2
  
configTemplates: my-config <4>
versionFile: my-versions.yaml <5>
----

<1> A human readable name of the *Product* for display purposes in the Web UI
<2> A unique ID of the *Product* which is used to base *Instances* of. This should not change, as changing the *Product* ID of an existing *Instance* is not supported.
<3> The actual *Applications* which are part of the *Product*. These IDs can be anything, they just have to match the IDs used in the `product-version.yaml` referenced below.
<4> An optional relative path to a directory containing configuration file templates, which will be used as the default set of configuration files when creating an *Instance* from the resulting *Product*.
<5> The `product-version.yaml` which associates the *Application* IDs (used above) with actual paths to *Applications* on the file system.

==== product-version.yaml

[NOTE]
There is no actual requirement for the file to be named `product-version.yaml` as it is referenced from the `product-info.yaml` by relative path anyway. This is just the default name.

The `product-version.yaml` file associates *Application* IDs used in the `product-info.yaml` with actual locations on the local disc. This is used to find an import each included *Application* when importing the *Product*.

The reason why this file is separate from the `product-info.yaml` in the first place, is to allow generation of it's content by a build system. It may contain build specific data (version, path to application binaries per operating system, etc.).

[source,yaml]
----
version: "2.1.0.201906141135" <1>
appInfo:
  my-app1: <2>
    WINDOWS: "build/windows/app-info.yaml" <3>
    LINUX: "build/linux/app-info.yaml"
  my-app2:
    WINDOWS: "scripts/app2/app-info.yaml" <4>
    LINUX: "scripts/app2/app-info.yaml"
----

<1> The version is used as *Manifest* _tag_, which is a more general concept. There is no requirement for any version-like syntax here, it can be basically anything. It should just be unique per *Product* version which can be installed on a *BDeploy* server.
<2> The *Application* ID must match the one used in `product-info.yaml`.
<3> You may have different binaries for a single application depending on the target operating system. It is not required to provide every application for every operating system. You can just leave out operating systems you don't care about.
<4> You can also use the exact same *Application* directory to satisfy multiple operating system targets.

=== Dependencies, third party Software

As you saw before (`<<_app_info_yaml,app-info.yaml>>`), *Applications* can declare dependencies to third-party *Manifests*. These *Manifests* are hosted in *Software Repositories* on the *BDeploy* Server.

To make them available on the server, you need to:

* Use `bhive import` to import the directory containing the third-party software into a local *BHive*.
* Use `bhive push` to push the created *Manifest* to the *Software Repository* of your choice.

==== Manifest Naming

Third party software *Manifests* can have basically any name. If you want to provide different *Manifests* per target operating system though, you will have to follow a simple naming rule: append the operating system name to the *Manifest* name part, e.g.:

* `my/external/software/windows:1.0.0`
* `my/external/software/linux:1.0.0`

It can then be referenced by an `app-info.yaml` using the short-hand syntax `my/external/software:1.0.0` and *BDeploy* will choose the correct one depending on the target operating system.

=== Building a Product

Now that you have a well-defined *Product* with one or more *Applications*, you will want to build/package that *Product* to be usable with *BDeploy*.

==== Via CLI

Once you have a `product-info.yaml` with it's `product-version.yaml` and all the `app-info.yaml` files in their respective *Application* directories, you can use the CLI to import the product as a single piece.

* Use `bdeploy product` to import the product by specifying a local *BHive* and the `product-info.yaml` to import from.
* Use `bhive push` to push the resulting *Product Manifest* from the local *BHive* to an *Instance Group* on a remote *BDeploy* server.

==== Via Eclipse TEA

*BDeploy* provides integration into https://www.eclipse.org/tea/[Eclipse TEA]. Using this integration, you can easily export *Eclipse RCP* based products as *Applications* and bundle them into a custom *Product*.

Once you have required files, select menu:TEA[TEA Build Library > Create BDeploy Product]. You will be prompted which *Product* to build if the configured `products.yaml` contains more than one *Product*. Otherwise *Eclipse TEA* will start building the *Product* right away.

===== `products.yaml`

[NOTE]
There is no actual requirement for the file to be named `product-info.yaml`. This is just the default, but you can specify another name on the command line or in build tool integrations.

This file is required an lists the `<<_product_build_yaml,product-build.yaml>>` files which are available to the integration.

[source,yaml]
----
products:
  "Product One": "prod-1-build.yaml"
  "Product Two": "prod-2-build.yaml"
----

The path to the `products.yaml` has to be configured in the *Eclipse TEA* preferences

image::images/TEA_preferences_products.png[TEA Integration Products Preference,align=center,width=480,link="images/TEA_preferences_products.png"]

===== `product-build.yaml`

This file references a `<<_product_info_yaml,product-info.yaml>>` file and describes how to build the actual applications referenced in the `product-info.yaml`.

[source,yaml]
----
productInfoYaml: my-prod-info.yaml

applications:
  - name: my-app1
    type: RCP_PRODUCT
    includeOs: [WINDOWS, LINUX]
    application:
      product: App1ProdBuild
        
  - name: my-app2
    type: RCP_PRODUCT
    includeOs: [WINDOWS, LINUX]
    application:
      product: App2ProdBuild
----

The value for `applications.application.product` is *Eclipse TEA* specific and references the *Eclipse TEA* product _alias_ property.
