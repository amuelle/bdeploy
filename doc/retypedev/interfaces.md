---
order: 7
icon: codescan
---
# Interfaces

## Model Class Naming

The classes in this project follow a strict naming scheme.

Class&nbsp;Name&nbsp;Suffix | Meaning
---                         | ---
`*Descriptor` | Things which are provided by the 'outside' world to describe artifacts processed by us.
`*Configuration` | Holds data generated by us, based on *Descriptors, user input, or even thin air.
`*Manifest` | Wraps and manages storage of *Configurations in the underlying BHives. Also handles enumeration/scanning for according objects in the BHive(s).
`*Dto` | (not actually in the interfaces project, but ui specific). Holds/groups data which is required in this form for user display/interaction in the UI.
`*Resource` | Interfaces for remote (JAX-RS) resources.
`*Provider` | Providers for variable expansion in configurations on the target system.

## Variable Expansion

This project contains the logic for resolving variables when deploying to a minion. The following schemes are supported.

Expansion of variables happens for launcher paths and parameter values. Additionally, all configuration files are post-processed on the target to perform the exact same expansion.

=== **Provider**: `ApplicationParameterProvider`
_Variable Pattern:_ `{{V:[APP:]PARAM}}` 

_Supported Values:_
* `APP`: _(optional)_ The name of the application to reference. If not given, the parameter is referenced within the same application as the referencing parameter 
* `PARAM`: The name of the parameter

_Example:_ `{{V:MyServer:my.param.id}}`

_Description:_ Expand the value of another parameter inline into the value of this parameter. 

=== **Provider**: `DeploymentPathProvider`
_Variable Pattern:_ `{{P:PATH_ID}}`

_Supported Values:_
* `CONFIG`: directory where all configuration files will be placed by deployment 
* `BIN`: directory where all binaries are placed by deployment 
* `RUNTIME`: directory with runtime data (e.d. stdout/stderr capture files) 
* `DATA`: persistent data directory - the only directory shared by multiple deployments of the same instance.

_Example:_ `{{P:CONFIG}}/myFile.json`

_Description:_ Expand one of the special directories (see `SpecialDirectory`) know by the deployment process.

=== **Provider**: `InstanceVariableResolver`
_Variable Pattern:_ `{{I:VAR}}`

_Supported Values:_
* `SYSTEM_PURPOSE`: the purpose of the instance, see `InstancePurpose` 
* `ID`: ID of the instance 
* `NAME`: name of the instance 
* `PRODUCT_ID`: name of the `MANIFEST` key's name of the configured product 
* `PRODUCT_TAG`: the tag (i.e. 'version') of the configured product

_Example:_ `{{I:SYSTEM_PURPOSE}}`

_Description:_ Expand values related to the instance containing the parameter's process

=== **Provider**: `ManifestRefPathProvider`
_Variable Pattern:_ `{{M:MANIFEST_NAME[:TAG]}}`

_Supported Values:_
* `MANIFEST_NAME`: the name of the manifest to reference. The variable will expand to the installation path of that other manifest. * TAG: _(optional)_ if given expand to the exact manifest version.

_Example:_ `{{M:openjdk/jre8}}/bin/java`

_Description:_ Expand the absolute installation path to another manifest's path on the target system.

=== **Provider**: `OsConditionalProvider`
_Variable Pattern:_ `{{OSNAME:VALUE}}`

_Supported Values:_
* `OSNAME`: either `OperatingSystem` value (`WINDOWS`, `LINUX`, `AIX`).
* `VALUE`: the target value to expand if the target OS matches the `OSNAME` value.

_Example:_ `.../bin/java{{WINDOWS:.exe}}`

_Description:_ Insert the given `VALUE` if and only if the given `OSNAME` (see `OperatingSystem`) matches.

=== **Provider**: `MinionConfigVariableResolver`
_Variable Pattern:_ `{{H:HOSTNAME}}`

_Supported Values:_
* `HOSTNAME`: expands to the hostname of the target minion where the application is deployed.

_Example:_ `{{H:HOSTNAME}}`

_Description:_ Expands to target minion properties - currently only `HOSTNAME` is supported.

===
